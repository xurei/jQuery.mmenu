//If node environment, reassign jquery to a fake window using jsdom
var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';
if (isNode) {
	var jsdom = require('jsdom').jsdom,
	global.window = jsdom('').defaultView;
	global.navigator = window.navigator;
	jQuery = jQuery(window);
}
/*
 * jQuery mmenu v5.7.8
 * @requires jQuery 1.7.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * License: CC-BY-NC-4.0
 * http://creativecommons.org/licenses/by-nc/4.0/
 */

(function( $ ) {

	var _PLUGIN_	= 'mmenu',
		_VERSION_	= '5.7.8';


	//	Plugin already excists
	if ( $[ _PLUGIN_ ] && $[ _PLUGIN_ ].version > _VERSION_ )
	{
		return;
	}


	/*
		Class
	*/
	$[ _PLUGIN_ ] = function( $menu, opts, conf )
	{
		this.$menu	= $menu;
		this._api	= [ 'bind', 'getInstance', 'update', 'initPanels', 'openPanel', 'closePanel', 'closeAllPanels', 'setSelected' ];
		this.opts	= opts;
		this.conf	= conf;
		this.vars	= {};
		this.cbck	= {};


		if ( typeof this.___deprecated == 'function' )
		{
			this.___deprecated();
		}


		this._initMenu();
		this._initAnchors();

		var $pnls = this.$pnls.children();
		
		this._initAddons();
		this.initPanels( $pnls );


		if ( typeof this.___debug == 'function' )
		{
			this.___debug();
		}

		return this;
	};

	$[ _PLUGIN_ ].version 	= _VERSION_;
	$[ _PLUGIN_ ].addons 	= {};
	$[ _PLUGIN_ ].uniqueId 	= 0;


	$[ _PLUGIN_ ].defaults 	= {
		extensions		: [],
		initMenu 		: function() {},
		initPanels 		: function() {},
		navbar 			: {
			add 			: true,
			title			: 'Menu',
			titleLink		: 'panel'
		},
		onClick			: {
//			close			: true,
//			preventDefault	: null,
			setSelected		: true
		},
		slidingSubmenus	: true
	};

	$[ _PLUGIN_ ].configuration = {
		classNames			: {
			divider		: 'Divider',
			inset 		: 'Inset',
			panel		: 'Panel',
			selected	: 'Selected',
			spacer		: 'Spacer',
			vertical	: 'Vertical'
		},
		clone				: false,
		openingInterval		: 25,
		panelNodetype		: 'ul, ol, div',
		transitionDuration	: 400
	};

	$[ _PLUGIN_ ].prototype = {

//	TEMP backward compat
init: function( $panels )
{
	this.initPanels( $panels );
},

		getInstance: function()
		{
			return this;
		},

		update: function()
		{
			this.trigger( 'update' );
		},

		initPanels: function( $panels )
		{
			$panels = $panels.not( '.' + _c.nopanel );
			$panels = this._initPanels( $panels );

			this.opts.initPanels.call( this, $panels );

			this.trigger( 'initPanels', $panels );
			this.trigger( 'update' );
		},

		openPanel: function( $panel )
		{
			var $l = $panel.parent(),
				that = this;

			//	Vertical
			if ( $l.hasClass( _c.vertical ) )
			{
				var $sub = $l.parents( '.' + _c.subopened );
				if ( $sub.length )
				{
					this.openPanel( $sub.first() );
					return;
				}
				$l.addClass( _c.opened );

				this.trigger( 'openPanel' 	, $panel );
				this.trigger( 'openingPanel', $panel );
				this.trigger( 'openedPanel'	, $panel );
			}

			//	Horizontal
			else
			{
				if ( $panel.hasClass( _c.current ) )
				{
					return;
				}

				var $panels = this.$pnls.children( '.' + _c.panel ),
					$current = $panels.filter( '.' + _c.current );

				$panels
					.removeClass( _c.highest )
					.removeClass( _c.current )
					.not( $panel )
					.not( $current )
					.not( '.' + _c.vertical )
					.addClass( _c.hidden );

				if ( !$[ _PLUGIN_ ].support.csstransitions )
				{
					$current.addClass( _c.hidden );
				}

				if ( $panel.hasClass( _c.opened ) )
				{
					$panel
						.nextAll( '.' + _c.opened )
						.addClass( _c.highest )
						.removeClass( _c.opened )
						.removeClass( _c.subopened );
				}
				else
				{
					$panel.addClass( _c.highest );
					$current.addClass( _c.subopened );
				}

				$panel
					.removeClass( _c.hidden )
					.addClass( _c.current );

				that.trigger( 'openPanel', $panel );

				//	Without the timeout the animation won't work because the element had display: none;
				setTimeout(
					function()
					{
						$panel
							.removeClass( _c.subopened )
							.addClass( _c.opened );

						that.trigger( 'openingPanel', $panel );

						//	Callback
						that.__transitionend( $panel,
							function()
							{
								that.trigger( 'openedPanel', $panel );
							}, that.conf.transitionDuration
						);

					}, this.conf.openingInterval
				);
			}
		},

		closePanel: function( $panel )
		{
			var $l = $panel.parent();

			//	Vertical only
			if ( $l.hasClass( _c.vertical ) )
			{
				$l.removeClass( _c.opened );

				this.trigger( 'closePanel'	, $panel );
				this.trigger( 'closingPanel', $panel );
				this.trigger( 'closedPanel'	, $panel );
			}
		},

		closeAllPanels: function()
		{
			//	Vertical
			this.$menu
				.find( '.' + _c.listview )
				.children()
				.removeClass( _c.selected )
				.filter( '.' + _c.vertical )
				.removeClass( _c.opened );

			//	Horizontal
			var $pnls = this.$pnls.children( '.' + _c.panel ),
				$frst = $pnls.first();

			this.$pnls
				.children( '.' + _c.panel )
				.not( $frst )
				.removeClass( _c.subopened )
				.removeClass( _c.opened )
				.removeClass( _c.current )
				.removeClass( _c.highest )
				.addClass( _c.hidden );

			this.openPanel( $frst );
		},
		
		togglePanel: function( $panel )
		{
			var $l = $panel.parent();

			//	Vertical only
			if ( $l.hasClass( _c.vertical ) )
			{
				this[ $l.hasClass( _c.opened ) ? 'closePanel' : 'openPanel' ]( $panel );
			}
		},

		setSelected: function( $li )
		{
			this.$menu.find( '.' + _c.listview ).children( '.' + _c.selected ).removeClass( _c.selected );
			$li.addClass( _c.selected );

			this.trigger( 'setSelected', $li );
		},

		bind: function( evnt, fn )
		{

//	TEMP backward compat
evnt = (evnt == 'init') ? 'initPanels' : evnt;

			this.cbck[ evnt ] = this.cbck[ evnt ] || [];
			this.cbck[ evnt ].push( fn );
		},

		trigger: function()
		{
			var that = this,
				args = Array.prototype.slice.call( arguments ),
				evnt = args.shift();

//	TEMP backward compat
evnt = (evnt == 'init') ? 'initPanels' : evnt;

			if ( this.cbck[ evnt ] )
			{
				for ( var e = 0, l = this.cbck[ evnt ].length; e < l; e++ )
                {
                    this.cbck[ evnt ][ e ].apply( that, args );
                }
			}
		},

		_initMenu: function()
		{
			var that = this;

			//	Clone if needed
			if ( this.conf.clone )
			{
				this.$orig = this.$menu;
				this.$menu = this.$orig.clone( true );
				this.$menu.add( this.$menu.find( '[id]' ) )
					.filter( '[id]' )
					.each(
						function()
						{
							$(this).attr( 'id', _c.mm( $(this).attr( 'id' ) ) );
						}
					);
			}

			//	Via options
			this.opts.initMenu.call( this, this.$menu, this.$orig );

			//	Add ID
			this.$menu.attr( 'id', this.$menu.attr( 'id' ) || this.__getUniqueId() );

			//	Add markup
			this.$pnls = $( '<div class="' + _c.panels + '" />' )
				.append( this.$menu.children( this.conf.panelNodetype ) )
				.prependTo( this.$menu );

			//	Add classes
			this.$menu
				.parent()
				.addClass( _c.wrapper );

			var clsn = [ _c.menu ];

			if ( !this.opts.slidingSubmenus )
			{
				clsn.push( _c.vertical );
			}

			//	Add extensions classes
			this.opts.extensions = this.opts.extensions.length ? 'mm-' + this.opts.extensions.join( ' mm-' ) : '';

			if ( this.opts.extensions )
			{
				clsn.push( this.opts.extensions );
			}

			this.$menu.addClass( clsn.join( ' ' ) );

			this.trigger( '_initMenu' );
		},

		_initPanels: function( $panels )
		{
			var that = this;

			var $lists = this.__findAddBack( $panels, 'ul, ol' );

			//	Add List classname
			this.__refactorClass( $lists, this.conf.classNames.inset, 'inset' )
				.addClass( _c.nolistview + ' ' + _c.nopanel );

			$lists.not( '.' + _c.nolistview )
				.addClass( _c.listview );

			var $lis = this.__findAddBack( $panels, '.' + _c.listview ).children();

			//	Refactor classnames
			this.__refactorClass( $lis, this.conf.classNames.selected, 'selected' );
			this.__refactorClass( $lis, this.conf.classNames.divider, 'divider' );
			this.__refactorClass( $lis, this.conf.classNames.spacer, 'spacer' );
			this.__refactorClass( this.__findAddBack( $panels, '.' + this.conf.classNames.panel ), this.conf.classNames.panel, 'panel' );

			//	Create panels
			var $curpanels = $(),
				$oldpanels = $panels
					.add( $panels.find( '.' + _c.panel ) )
					.add( this.__findAddBack( $panels, '.' + _c.listview ).children().children( this.conf.panelNodetype ) )
					.not( '.' + _c.nopanel );

			this.__refactorClass( $oldpanels, this.conf.classNames.vertical, 'vertical' );
			
			if ( !this.opts.slidingSubmenus )
			{
				$oldpanels.addClass( _c.vertical );
			}

			$oldpanels
				.each(
					function()
					{
						var $t = $(this),
							$p = $t;

						if ( $t.is( 'ul, ol' ) )
						{
							$t.wrap( '<div class="' + _c.panel + '" />' );
							$p = $t.parent();
						}
						else
						{
							$p.addClass( _c.panel );
						}

						var id = $t.attr( 'id' );
						$t.removeAttr( 'id' );
						$p.attr( 'id', id || that.__getUniqueId() );

						if ( $t.hasClass( _c.vertical ) )
						{
							$t.removeClass( that.conf.classNames.vertical );
							$p.add( $p.parent() ).addClass( _c.vertical );
						}

						$curpanels = $curpanels.add( $p );
					} 
				);

			var $allpanels = $('.' + _c.panel, this.$menu);

			//	Add open and close links to menu items
			$curpanels
				.each(
					function( i )
					{
						var $t = $(this),
							$p = $t.parent(),
							$a = $p.children( 'a, span' ).first();

						var id, $b;

						if ( !$p.is( '.' + _c.panels ) )
						{
							$p.data( _d.child, $t );
							$t.data( _d.parent, $p );
						}

						//	Open link
						if ( !$p.children( '.' + _c.next ).length )
						{
							if ( $p.parent().is( '.' + _c.listview ) )
							{
								id = $t.attr( 'id' );
								$b = $( '<a class="' + _c.next + '" href="#' + id + '" data-target="#' + id + '" />' ).insertBefore( $a );

								if ( $a.is( 'span' ) )
								{
									$b.addClass( _c.fullsubopen );
								}
							}
						}

						//	Navbar
						if ( $t.children( '.' + _c.navbar ).length ||
							$p.hasClass( _c.vertical )
						) {
							return;
						}

						if ( $p.parent().is( '.' + _c.listview ) )
						{
							//	Listview, the panel wrapping this panel
							$p = $p.closest( '.' + _c.panel );
						}
						else
						{
							//	Non-listview, the first panel that has an anchor that links to this panel
							$a = $p.closest( '.' + _c.panel ).find( 'a[href="#' + $t.attr( 'id' ) + '"]' ).first();
							$p = $a.closest( '.' + _c.panel );
						}
						
						// fix: _url undefined
						var _url = false;
						var $navbar = $( '<div class="' + _c.navbar + '" />' );

						if ( that.opts.navbar.add )
						{
							$t.addClass( _c.hasnavbar );
						}

						if ( $p.length )
						{
							id = $p.attr( 'id' );
							switch ( that.opts.navbar.titleLink )
							{
								case 'anchor':
									_url = $a.attr( 'href' );
									break;

								case 'panel':
								case 'parent':
									_url = '#' + id;
									break;

								default:
									_url = false;
									break;
							}

							$navbar
								.append( '<a class="' + _c.btn + ' ' + _c.prev + '" href="#' + id + '" data-target="#' + id + '" />' )
								.append( $('<a class="' + _c.title + '"' + ( _url ? ' href="' + _url + '"' : '' ) + ' />').text( $a.text() ) )
								.prependTo( $t );
						}
						else if ( that.opts.navbar.title )
						{
							$navbar
								.append( '<a class="' + _c.title + '">' + $[ _PLUGIN_ ].i18n( that.opts.navbar.title ) + '</a>' )
								.prependTo( $t );
						}
					}
				);


			//	Add opened-classes to parents
			var $s = this.__findAddBack( $panels, '.' + _c.listview )
				.children( '.' + _c.selected )
				.removeClass( _c.selected )
				.last()
				.addClass( _c.selected );

			$s.add( $s.parentsUntil( '.' + _c.menu, 'li' ) )
				.filter( '.' + _c.vertical )
				.addClass( _c.opened )
				.end()
				.each(
					function()
					{
						$(this).parentsUntil( '.' + _c.menu, '.' + _c.panel )
							.not( '.' + _c.vertical )
							.first()
							.addClass( _c.opened )
							.parentsUntil( '.' + _c.menu, '.' + _c.panel )
							.not( '.' + _c.vertical )
							.first()
							.addClass( _c.opened )
							.addClass( _c.subopened );
					}
				);


			//	Add opened-classes to child
			$s.children( '.' + _c.panel )
				.not( '.' + _c.vertical )
				.addClass( _c.opened )
				.parentsUntil( '.' + _c.menu, '.' + _c.panel )
				.not( '.' + _c.vertical )
				.first()
				.addClass( _c.opened )
				.addClass( _c.subopened );


			//	Set current opened
			var $current = $allpanels.filter( '.' + _c.opened );
			if ( !$current.length )
			{
				$current = $curpanels.first();
			}
			$current
				.addClass( _c.opened )
				.last()
				.addClass( _c.current );


			//	Rearrange markup
			$curpanels
				.not( '.' + _c.vertical )
				.not( $current.last() )
				.addClass( _c.hidden )
				.end()
				.filter(
					function()
					{
						return !$(this).parent().hasClass( _c.panels  );
					}
				)
				.appendTo( this.$pnls );

			this.trigger( '_initPanels', $curpanels );

			return $curpanels;
		},

		_initAnchors: function()
		{
			var that = this;

			glbl.$body
				.on( _e.click + '-oncanvas',
					'a[href]',
					function( e )
					{
						var $t = $(this),
							fired 	= false,
							inMenu 	= that.$menu.find( $t ).length;

						//	Find behavior for addons
						for ( var a in $[ _PLUGIN_ ].addons )
						{
							if ( $[ _PLUGIN_ ].addons[ a ].clickAnchor.call( that, $t, inMenu ) )
							{
								fired = true;
								break;
							}
						}

						var _h = $t.attr( 'href' );

						//	Open/Close panel
						if ( !fired && inMenu )
						{
							if ( _h.length > 1 && _h.slice( 0, 1 ) == '#' )
							{
								try
								{
									var $h = $(_h, that.$menu);
									if ( $h.is( '.' + _c.panel ) )
									{
										fired = true;
										that[ $t.parent().hasClass( _c.vertical ) ? 'togglePanel' : 'openPanel' ]( $h );
									}
								}
								catch( err ) {}
							}
						}

						if ( fired )
						{
							e.preventDefault();
						}


						//	All other anchors in lists
						if ( !fired && inMenu )
						{
							if ( $t.is( '.' + _c.listview + ' > li > a' ) && !$t.is( '[rel="external"]' ) && !$t.is( '[target="_blank"]' ) )
							{

								//	Set selected item
								if ( that.__valueOrFn( that.opts.onClick.setSelected, $t ) )
								{
									that.setSelected( $(e.target).parent() );
								}
	
								//	Prevent default / don't follow link. Default: false
								var preventDefault = that.__valueOrFn( that.opts.onClick.preventDefault, $t, _h.slice( 0, 1 ) == '#' );
								if ( preventDefault )
								{
									e.preventDefault();
								}

								//	Close menu. Default: true if preventDefault, false otherwise
								if ( that.__valueOrFn( that.opts.onClick.close, $t, preventDefault ) )
								{
									that.close();
								}
							}
						}
					}
				);

			this.trigger( '_initAnchors' );
		},

		_initAddons: function()
		{
			//	Add add-ons to plugin
			var a;
			for ( a in $[ _PLUGIN_ ].addons )
			{
				$[ _PLUGIN_ ].addons[ a ].add.call( this );
				$[ _PLUGIN_ ].addons[ a ].add = function() {};
			}

			//	Setup adds-on for menu
			for ( a in $[ _PLUGIN_ ].addons )
			{
				$[ _PLUGIN_ ].addons[ a ].setup.call( this );
			}

			this.trigger( '_initAddons' );
		},

		_getOriginalMenuId: function()
		{
			var id = this.$menu.attr( 'id' );
			if ( id && id.length )
			{
				if ( this.conf.clone )
				{
					id = _c.umm( id );
				}
			}
			return id;
		},

		__api: function()
		{
			var that = this,
				api = {};

			$.each( this._api, 
				function( i )
				{
					var fn = this;
					api[ fn ] = function()
					{
						var re = that[ fn ].apply( that, arguments );
						return ( typeof re == 'undefined' ) ? api : re;
					};
				}
			);
			return api;
		},

		__valueOrFn: function( o, $e, d )
		{
			if ( typeof o == 'function' )
			{
				return o.call( $e[ 0 ] );
			}
			if ( typeof o == 'undefined' && typeof d != 'undefined' )
			{
				return d;
			}
			return o;
		},

		__refactorClass: function( $e, o, c )
		{
			return $e.filter( '.' + o ).removeClass( o ).addClass( _c[ c ] );
		},

		__findAddBack: function( $e, s )
		{
			return $e.find( s ).add( $e.filter( s ) );
		},

		__filterListItems: function( $i )
		{
			return $i
				.not( '.' + _c.divider )
				.not( '.' + _c.hidden );
		},

		__transitionend: function( $e, fn, duration )
		{
			var _ended = false,
				_fn = function( e )
				{

					if ( typeof e !== 'undefined' )
					{
						if ( $(e.target).is( $e ) )
						{
							$e.unbind( _e.transitionend );
							$e.unbind( _e.webkitTransitionEnd );
						}
						else
						{
							return false;
						}
					}

					if ( !_ended )
					{
						fn.call( $e[ 0 ] );
					}
					_ended = true;
				};
	
			$e.on( _e.transitionend, _fn );
			$e.on( _e.webkitTransitionEnd, _fn );
			setTimeout( _fn, duration * 1.1 );
		},
		
		__getUniqueId: function()
		{
			return _c.mm( $[ _PLUGIN_ ].uniqueId++ );
		}
	};


	/*
		jQuery plugin
	*/
	$.fn[ _PLUGIN_ ] = function( opts, conf )
	{
		//	First time plugin is fired
		initPlugin();

		//	Extend options
		opts = $.extend( true, {}, $[ _PLUGIN_ ].defaults, opts );
		conf = $.extend( true, {}, $[ _PLUGIN_ ].configuration, conf );

		var $result = $();
		this.each(
			function()
			{
				var $menu = $(this);
				if ( $menu.data( _PLUGIN_ ) )
				{
					return;
				}

				var _menu = new $[ _PLUGIN_ ]( $menu, opts, conf );
				_menu.$menu.data( _PLUGIN_, _menu.__api() );

				$result = $result.add( _menu.$menu );
			}
		);

		return $result;
	};


	/*
		I18N
	*/
	$[ _PLUGIN_ ].i18n = (function() {

		var trns = {};

		return function( t )
		{
			switch( typeof t )
			{
				case 'object':
					$.extend( trns, t );
					return trns;
					break;

				case 'string':
					return trns[ t ] || t;
					break;

				case 'undefined':
				default:
					return trns;
					break;
			}
		};
	})();


	/*
		SUPPORT
	*/
	$[ _PLUGIN_ ].support = {
		touch: 'ontouchstart' in window || navigator.msMaxTouchPoints || false,
		csstransitions: (function()
		{
			//	Use Modernizr test
			if ( typeof Modernizr !== 'undefined' &&
				 typeof Modernizr.csstransitions !== 'undefined'
			) {
				return Modernizr.csstransitions;
			}

			var b = document.body || document.documentElement,
				s = b.style,
				p = 'transition';

			//	Default support
			if ( typeof s[ p ] == 'string' )
			{
				return true;
			}

			//	Vendor specific support
			var v = [ 'Moz', 'webkit', 'Webkit', 'Khtml', 'O', 'ms' ];
			p = p.charAt( 0 ).toUpperCase() + p.substr( 1 );

			for ( var i = 0; i < v.length; i++ )
			{
				if ( typeof s[ v[ i ] + p ] == 'string' )
				{
					return true;
				}
			}

			//	No support
			return false;
		})(),
		csstransforms: (function() {
			if ( typeof Modernizr !== 'undefined' &&
				 typeof Modernizr.csstransforms !== 'undefined'
			) {
				return Modernizr.csstransforms;
			}

			//	w/o Modernizr, we'll assume you only support modern browsers :/
			return true;
		})(),
		csstransforms3d: (function() {
			if ( typeof Modernizr !== 'undefined' &&
				 typeof Modernizr.csstransforms3d !== 'undefined'
			) {
				return Modernizr.csstransforms3d;
			}

			//	w/o Modernizr, we'll assume you only support modern browsers :/
			return true;
		})()
	};


	//	Global variables
	var _c, _d, _e, glbl;

	function initPlugin()
	{
		if ( $[ _PLUGIN_ ].glbl )
		{
			return;
		}

		glbl = {
			$wndw : $(window),
			$docu : $(document),
			$html : $('html'),
			$body : $('body')
		};


		//	Classnames, Datanames, Eventnames
		_c = {};
		_d = {};
		_e = {};

		$.each( [ _c, _d, _e ],
			function( i, o )
			{
				o.add = function( a )
				{
					a = a.split( ' ' );
					for ( var b = 0, l = a.length; b < l; b++ )
					{
						o[ a[ b ] ] = o.mm( a[ b ] );
					}
				};
			}
		);

		//	Classnames
		_c.mm = function( c ) { return 'mm-' + c; };
		_c.add( 'wrapper menu panels panel nopanel current highest opened subopened navbar hasnavbar title btn prev next listview nolistview inset vertical selected divider spacer hidden fullsubopen' );
		_c.umm = function( c )
		{
			if ( c.slice( 0, 3 ) == 'mm-' )
			{
				c = c.slice( 3 );
			}
			return c;
		};

		//	Datanames
		_d.mm = function( d ) { return 'mm-' + d; };
		_d.add( 'parent child' );

		//	Eventnames
		_e.mm = function( e ) { return e + '.mm'; };
		_e.add( 'transitionend webkitTransitionEnd click scroll keydown mousedown mouseup touchstart touchmove touchend orientationchange' );


		$[ _PLUGIN_ ]._c = _c;
		$[ _PLUGIN_ ]._d = _d;
		$[ _PLUGIN_ ]._e = _e;

		$[ _PLUGIN_ ].glbl = glbl;
	}


})( jQuery );

/*	
 * jQuery mmenu offCanvas add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'offCanvas';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			if ( !this.opts[ _ADDON_ ] )
			{
				return;
			}

			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Add methods to api
			this._api = $.merge( this._api, [ 'open', 'close', 'setPage' ] );


			//	Extend options
			if ( opts.position == 'top' || opts.position == 'bottom' )
			{
				opts.zposition = 'front';
			}


			//	Extend configuration
			if ( typeof conf.pageSelector != 'string' )
			{
				conf.pageSelector = '> ' + conf.pageNodetype;
			}


			glbl.$allMenus = ( glbl.$allMenus || $() ).add( this.$menu );


			//	Setup the menu
			this.vars.opened = false;
			
			var clsn = [ _c.offcanvas ];

			if ( opts.position != 'left' )
			{
				clsn.push( _c.mm( opts.position ) );
			}
			if ( opts.zposition != 'back' )
			{
				clsn.push( _c.mm( opts.zposition ) );
			}

			this.$menu
				.addClass( clsn.join( ' ' ) )
				.parent()
				.removeClass( _c.wrapper );

			if ( !$[ _PLUGIN_ ].support.csstransforms )
			{
				this.$menu.addClass( _c[ 'no-csstransforms' ] );
			}
			if ( !$[ _PLUGIN_ ].support.csstransforms3d )
			{
				this.$menu.addClass( _c[ 'no-csstransforms3d' ] );
			}


			//	Setup the page
			this.setPage( glbl.$page );


			//	Setup the UI blocker and the window
			this._initBlocker();
			this[ '_initWindow_' + _ADDON_ ]();


			//	Append to the body
			this.$menu[ conf.menuInjectMethod + 'To' ]( conf.menuWrapperSelector );


			//	Open if url hash equals menu id (usefull when user clicks the hamburger icon before menu created)
			var hash = window.location.hash;
			if ( hash )
			{
				var id = this._getOriginalMenuId();
				if ( id && id == hash.slice( 1 ) )
				{
					this.open();
				}
			}

		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

			_c.add( 'offcanvas slideout blocking modal background opening blocker page no-csstransforms3d' );
			_d.add( 'style' );
			_e.add( 'resize' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu )
		{
			var that = this;

			if ( !this.opts[ _ADDON_ ] )
			{
				return;
			}

			//	Open menu
			var id = this._getOriginalMenuId();
			if ( id )
			{
				if ( $a.is( '[href="#' + id + '"]' ) )
				{

					//	Opening this menu from within this menu
					//		-> Do nothing
					if ( inMenu )
					{
						return true;
					}

					//	Opening this menu from within a second menu
					//		-> Close the second menu before opening this menu
					var $m = $a.closest( '.' + _c.menu );
					if ( $m.length )
					{
						var _m = $m.data( 'mmenu' );
						if ( _m && _m.close )
						{
							_m.close();
							that.__transitionend( $m,
								function()
								{
									that.open();
								}, that.conf.transitionDuration
							);
							return true;
						}
					}

					//	Opening this menu
					this.open();
					return true;
				}
			}

			//	Close menu
			if ( !glbl.$page )
			{
				return;
			}

			id = glbl.$page.first().attr( 'id' );
			if ( id )
			{
				if ( $a.is( '[href="#' + id + '"]' ) )
				{
					this.close();
					return true;
				}
			}

			return;
		}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		position		: 'left',
		zposition		: 'back',
		blockUI			: true,
		moveBackground	: true
	};
	$[ _PLUGIN_ ].configuration[ _ADDON_ ] = {
		pageNodetype		: 'div',
		pageSelector		: null,
		noPageSelector		: [],
		wrapPageIfNeeded	: true,
		menuWrapperSelector	: 'body',
		menuInjectMethod	: 'prepend'
	};


	//	Methods
	$[ _PLUGIN_ ].prototype.open = function()
	{
		if ( this.vars.opened )
		{
			return;
		}

		var that = this;

		this._openSetup();

		//	Without the timeout, the animation won't work because the menu had display: none;
		setTimeout(
			function()
			{
				that._openFinish();
			}, this.conf.openingInterval
		);
		this.trigger( 'open' );
	};

	$[ _PLUGIN_ ].prototype._openSetup = function()
	{
		var that = this,
			opts = this.opts[ _ADDON_ ];

		//	Close other menus
		this.closeAllOthers();

		//	Store style and position
		glbl.$page.each(
			function()
			{
				$(this).data( _d.style, $(this).attr( 'style' ) || '' );
			}
		);

		//	Trigger window-resize to measure height
		glbl.$wndw.trigger( _e.resize + '-' + _ADDON_, [ true ] );

		var clsn = [ _c.opened ];

		//	Add options
		if ( opts.blockUI )
		{
			clsn.push( _c.blocking );
		}
		if ( opts.blockUI == 'modal' )
		{
			clsn.push( _c.modal );
		}
		if ( opts.moveBackground )
		{
			clsn.push( _c.background );
		}
		if ( opts.position != 'left' )
		{
			clsn.push( _c.mm( this.opts[ _ADDON_ ].position ) );
		}
		if ( opts.zposition != 'back' )
		{
			clsn.push( _c.mm( this.opts[ _ADDON_ ].zposition ) );
		}
		if ( this.opts.extensions )
		{
			clsn.push( this.opts.extensions );
		}
		glbl.$html.addClass( clsn.join( ' ' ) );

		//	Open
		//	Without the timeout, the animation won't work because the menu had display: none;
		setTimeout(
			function()
			{
            	that.vars.opened = true;
        	}, this.conf.openingInterval
        );

		this.$menu.addClass( _c.current + ' ' + _c.opened );
	};

	$[ _PLUGIN_ ].prototype._openFinish = function()
	{
		var that = this;

		//	Callback
		this.__transitionend( glbl.$page.first(),
			function()
			{
				that.trigger( 'opened' );
			}, this.conf.transitionDuration
		);

		//	Opening
		glbl.$html.addClass( _c.opening );
		this.trigger( 'opening' );
	};

	$[ _PLUGIN_ ].prototype.close = function()
	{

		if ( !this.vars.opened )
		{
			return;
		}

		var that = this;

		//	Callback
		this.__transitionend( glbl.$page.first(),
			function()
			{
				that.$menu.removeClass( _c.current + ' ' + _c.opened );

				var clsn = [
					_c.opened,
					_c.blocking,
					_c.modal,
					_c.background,
					_c.mm( that.opts[ _ADDON_ ].position ),
					_c.mm( that.opts[ _ADDON_ ].zposition )
				];

				if ( that.opts.extensions )
				{
					clsn.push( that.opts.extensions );
				}

				glbl.$html.removeClass( clsn.join( ' ' ) );

				//	Restore style and position
				glbl.$page.each(
					function()
					{
						$(this).attr( 'style', $(this).data( _d.style ) );
					}
				);

				that.vars.opened = false;
				that.trigger( 'closed' );

			}, this.conf.transitionDuration
		);

		//	Closing
		glbl.$html.removeClass( _c.opening );
		
		this.trigger( 'close' );
		this.trigger( 'closing' );
	};

	$[ _PLUGIN_ ].prototype.closeAllOthers = function()
	{
		glbl.$allMenus
			.not( this.$menu )
			.each(
				function()
				{
					var api = $(this).data( _PLUGIN_ );
					if ( api && api.close )
					{
						api.close();
					}
				}
			);
	};

	$[ _PLUGIN_ ].prototype.setPage = function( $page )
	{
		var that = this,
			conf = this.conf[ _ADDON_ ];

		if ( !$page || !$page.length )
		{
			$page = glbl.$body.find( conf.pageSelector );

			if ( conf.noPageSelector.length )
			{
				$page = $page.not( conf.noPageSelector.join( ', ' ) );
			}
			if ( $page.length > 1 && conf.wrapPageIfNeeded )
			{
				$page = $page
					.wrapAll( '<' + this.conf[ _ADDON_ ].pageNodetype + ' />' )
					.parent();
			}
		}

		$page.each(
			function()
			{
				$(this).attr( 'id', $(this).attr( 'id' ) || that.__getUniqueId() );		
			}
		);
		$page.addClass( _c.page + ' ' + _c.slideout );
		glbl.$page = $page;

		this.trigger( 'setPage', $page );
	};

	$[ _PLUGIN_ ].prototype[ '_initWindow_' + _ADDON_ ] = function()
	{
		//	Prevent tabbing
		glbl.$wndw
			.off( _e.keydown + '-' + _ADDON_ )
			.on(  _e.keydown + '-' + _ADDON_,
				function( e )
				{
					if ( glbl.$html.hasClass( _c.opened ) )
					{
						if ( e.keyCode == 9 )
						{
							e.preventDefault();
							return false;
						}
					}
				}
			);

		//	Set page min-height to window height
		var _h = 0;
		glbl.$wndw
			.off( _e.resize + '-' + _ADDON_ )
			.on(  _e.resize + '-' + _ADDON_,
				function( e, force )
				{
					if ( glbl.$page.length == 1 )
					{
						if ( force || glbl.$html.hasClass( _c.opened ) )
						{
							var nh = glbl.$wndw.height();
							if ( force || nh != _h )
							{
								_h = nh;
								glbl.$page.css( 'minHeight', nh );
							}
						}
					}
				}
			);
	};

	$[ _PLUGIN_ ].prototype._initBlocker = function()
	{
		var that = this;

		if ( !this.opts[ _ADDON_ ].blockUI )
		{
			return;
		}

		if ( !glbl.$blck )
		{
			glbl.$blck = $( '<div id="' + _c.blocker + '" class="' + _c.slideout + '" />' );
		}

		glbl.$blck
			.appendTo( glbl.$body )
			.off( _e.touchstart + '-' + _ADDON_ + ' ' + _e.touchmove + '-' + _ADDON_ )
			.on(  _e.touchstart + '-' + _ADDON_ + ' ' + _e.touchmove + '-' + _ADDON_,
				function( e )
				{
					e.preventDefault();
					e.stopPropagation();
					glbl.$blck.trigger( _e.mousedown + '-' + _ADDON_ );
				}
			)
			.off( _e.mousedown + '-' + _ADDON_ )
			.on(  _e.mousedown + '-' + _ADDON_,
				function( e )
				{
					e.preventDefault();
					if ( !glbl.$html.hasClass( _c.modal ) )
					{
						that.closeAllOthers();
						that.close();
					}
				}
			);
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu scrollBugFix add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'scrollBugFix';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			if ( !$[ _PLUGIN_ ].support.touch || !this.opts.offCanvas || !this.opts.offCanvas.blockUI )
			{
				return;
			}


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					fix: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );

			if ( !opts.fix )
			{
				return;
			}


			var id = this.$menu.attr( 'id' ),
				scrolling = false;


			this.bind( 'opening',
				function()
				{
					this.$pnls.children( '.' + _c.current ).scrollTop( 0 );
				}
			);

		    //	Prevent body scroll
		    glbl.$docu
		    	.on( _e.touchmove,
			    	function( e )
			    	{
						if ( that.vars.opened )
						{
							e.preventDefault();
						}
			    	}
			    );

		    glbl.$body
		    	.on( _e.touchstart,
			    	'#' + id + '> .' + _c.panels + '> .' + _c.current,
			    	function( e )
			    	{
				        if ( that.vars.opened )
				        {
				        	if ( !scrolling )
							{
							    scrolling = true;   
	    
						        if ( e.currentTarget.scrollTop === 0 )
						        {
						            e.currentTarget.scrollTop = 1;
						        }
						        else if ( e.currentTarget.scrollHeight === e.currentTarget.scrollTop + e.currentTarget.offsetHeight )
						        {
						            e.currentTarget.scrollTop -= 1;
						        }

							    scrolling = false;
							}
				        }
			    	}
			    )
		 		.on( _e.touchmove,
			 		'#' + id + '> .' + _c.panels + '> .' + _c.current,
			 		function( e )
			 		{
				        if ( that.vars.opened )
				        {
					        if ( $(this)[ 0 ].scrollHeight > $(this).innerHeight() )
					        {
					        	e.stopPropagation();
					        }
				        }
			    	}
		    	);

		    //	Fix issue after device rotation change
		    glbl.$wndw
		    	.on( _e.orientationchange,
		    		function()
		    		{
		    			that.$pnls
		    				.children( '.' + _c.current )
				        	.scrollTop( 0 )
				        	.css({ '-webkit-overflow-scrolling': 'auto' })
				        	.css({ '-webkit-overflow-scrolling': "touch" });
					}
		    	);
  
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		fix: true
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu backButton add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'backButton';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			if ( !this.opts.offCanvas )
			{
				return;
			}

			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					close	: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );
			

			//	Close menu
			if ( opts.close )
			{
				var _hash = '#' + that.$menu.attr( 'id' );
				this.bind( 'opened',
					function( e )
					{
						if ( location.hash != _hash )
						{
							history.pushState( null, document.title, _hash );
						}
					}
				);

				$(window).on( 'popstate',
					function( e )
					{
	
						if ( glbl.$html.hasClass( _c.opened ) )
						{
							e.stopPropagation();
							that.close();
						}
						else if ( location.hash == _hash )
						{
							e.stopPropagation();
							that.open();
						}
					}
				);
			}
		},

		//	add: fired once per page load
		add: function()
		{
			if ( !window.history || !window.history.pushState )
			{
				$[ _PLUGIN_ ].addons[ _ADDON_ ].setup = function() {};
				return;
			}

			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		close: false
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu autoHeight add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'autoHeight';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			if ( !this.opts.offCanvas )
			{
				return;
			}

			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' && opts )
			{
				opts = {
					height: 'auto'
				};
			}
			if ( typeof opts == 'string' )
			{
				opts = {
					height: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			if ( opts.height != 'auto' && opts.height != 'highest' )
			{
				return;
			}

			this.$menu.addClass( _c.autoheight );


			//	Update the height
			var update = function( $panl )
			{
				if ( !this.vars.opened )
				{
					return;
				}

				var _top = parseInt( this.$pnls.css( 'top' )	, 10 ) || 0,
					_bot = parseInt( this.$pnls.css( 'bottom' )	, 10 ) || 0,
					_hgh = 0;

				this.$menu.addClass( _c.measureheight );

				if ( opts.height == 'auto' )
				{
					$panl = $panl || this.$pnls.children( '.' + _c.current );
					if ( $panl.is( '.' + _c.vertical ) )
					{
						$panl = $panl
							.parents( '.' + _c.panel )
							.not( '.' + _c.vertical )
							.first();
					}
					_hgh = $panl.outerHeight();
				}
				else if ( opts.height == 'highest' )
				{
					this.$pnls.children()
						.each(
							function()
							{
								var $panl = $(this);
								if ( $panl.is( '.' + _c.vertical ) )
								{
									$panl = $panl
										.parents( '.' + _c.panel )
										.not( '.' + _c.vertical )
										.first();
								}
								_hgh = Math.max( _hgh, $panl.outerHeight() );
							}
						);
				}

				this.$menu
					.height( _hgh + _top + _bot )
					.removeClass( _c.measureheight );
			};

			this.bind( 'opening', update );

			if ( opts.height == 'highest' )
			{
				this.bind( 'initPanels', update );
			}
			if ( opts.height == 'auto' )
			{
				this.bind( 'update', update );
				this.bind( 'openPanel', update );
				this.bind( 'closePanel', update );
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

 			_c.add( 'autoheight measureheight' );
			_e.add( 'resize' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		height: 'default' // 'default/highest/auto'
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu columns add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'columns';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					add 	: opts
				};
			}
			if ( typeof opts == 'number' )
			{
				opts = {
					add 	: true,
					visible : opts
				};
			}

			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			if ( typeof opts.visible == 'number' )
			{
				opts.visible = {
					min 	: opts.visible,
					max 	: opts.visible
				};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			//	Add the columns
			if ( opts.add )
			{
				opts.visible.min = Math.max( 1, Math.min( 6, opts.visible.min ) );
				opts.visible.max = Math.max( opts.visible.min, Math.min( 6, opts.visible.max ) );

				this.$menu.addClass( _c.columns );

				var $nds = ( this.opts.offCanvas ) ? this.$menu.add( glbl.$html ) : this.$menu,
					clsn = [];

				for ( var i = 0; i <= opts.visible.max; i++ )
				{
					clsn.push( _c.columns + '-' + i );
				}
				clsn = clsn.join( ' ' );

				var initPanel = function( $panels )
				{
					openPanel.call( this, this.$pnls.children( '.' + _c.current ) );
				};
				var openMenu = function()
				{
					var _num = this.$pnls.children( '.' + _c.panel ).filter( '.' + _c.opened ).length;
					_num = Math.min( opts.visible.max, Math.max( opts.visible.min, _num ) );

					$nds.removeClass( clsn )
						.addClass( _c.columns + '-' + _num );
				};
				var closeMenu = function()
				{
					if ( this.opts.offCanvas )
					{
						glbl.$html.removeClass( clsn );
					}
				};
				var openPanel = function( $panel )
				{
					this.$pnls
						.children( '.' + _c.panel )
						.removeClass( clsn )
						.filter( '.' + _c.subopened )
						.removeClass( _c.hidden )
						.add( $panel )
						.slice( -opts.visible.max )
						.each(
							function( x )
							{
								$(this).addClass( _c.columns + '-' + x );
							}
						);
				};

				this.bind( 'open', openMenu );
				this.bind( 'close', closeMenu );
				this.bind( 'initPanels', initPanel );
				this.bind( 'openPanel', openPanel );
				this.bind( 'openingPanel', openMenu );
				this.bind( 'openedPanel', openMenu );

				if ( !this.opts.offCanvas )
				{
					openMenu.call( this );
				}
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;
	
			_c.add( 'columns' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu )
		{
			if ( !this.opts[ _ADDON_ ].add )
			{
				return false;
			}

			if ( inMenu )
			{
				var that = this;

				var _h = $a.attr( 'href' );
				if ( _h.length > 1 && _h.slice( 0, 1 ) == '#' )
				{
					try
					{
						var $h = $(_h, this.$menu);
						if ( $h.is( '.' + _c.panel ) )
						{
							var colnr = parseInt( $a.closest( '.' + _c.panel ).attr( 'class' ).split( _c.columns + '-' )[ 1 ].split( ' ' )[ 0 ], 10 ) + 1;
							while( colnr !== false )
							{
								var $panl = this.$pnls.children( '.' + _c.columns + '-' + colnr );
								if ( $panl.length )
								{
									colnr++;
									$panl
										.removeClass( _c.subopened )
										.removeClass( _c.opened )
										.removeClass( _c.current )
										.removeClass( _c.highest )
										.addClass( _c.hidden );
								}
								else
								{
									colnr = false;
									break;
								}
							}
						}
					}
					catch( err ) {}
				}
			}
		}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		add 		: false,
		visible		: {
			min			: 1,
			max			: 3
		}
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu counters add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'counters';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					add		: opts,
					update	: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			//	Refactor counter class
			this.bind( 'initPanels',
				function( $panels )
				{
					this.__refactorClass( $('em', $panels), this.conf.classNames[ _ADDON_ ].counter, 'counter' );
				}
			);


			//	Add the counters
			if ( opts.add )
			{
				this.bind( 'initPanels',
					function( $panels )
					{
						var $wrapper;
						switch( opts.addTo )
						{
							case 'panels':
								$wrapper = $panels;
								break;
			
							default:
								$wrapper = $panels.filter( opts.addTo );
								break;
						}

						$wrapper
							.each(
								function()
								{
									var $prnt = $(this).data( _d.parent );
									if ( $prnt )
									{
										if ( !$prnt.children( 'em.' + _c.counter ).length )
										{
											$prnt.prepend( $( '<em class="' + _c.counter + '" />' ) );
										}
									}
								}
							);
					}
				);
			}

			if ( opts.update )
			{
				this.bind( 'update',
					function()
					{
						this.$pnls
							.find( '.' + _c.panel )
							.each(
								function()
								{
									var $panl = $(this),
										$prnt = $panl.data( _d.parent );

									if ( !$prnt )
									{
										return;
									}

									var $cntr = $prnt.children( 'em.' + _c.counter );
									if ( !$cntr.length )
									{
										return;
									}

									$panl = $panl.children( '.' + _c.listview );
									if ( !$panl.length )
									{
										return;
									}

									$cntr.html( that.__filterListItems( $panl.children() ).length );
								}
							);
					}
				);
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;
	
			_c.add( 'counter search noresultsmsg' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		add		: false,
		addTo	: 'panels',
		update	: false
	};
	$[ _PLUGIN_ ].configuration.classNames[ _ADDON_ ] = {
		counter: 'Counter'
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu dividers add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'dividers';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					add		: opts,
					fixed	: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			//	Refactor collapsed class
			this.bind( 'initPanels',
				function( $panels )
				{
					this.__refactorClass( $('li', this.$menu), this.conf.classNames[ _ADDON_ ].collapsed, 'collapsed' );
				}
			);


			//	Add dividers
			if ( opts.add )
			{
				this.bind( 'initPanels',
					function( $panels )
					{
						var $wrapper;
						switch( opts.addTo )
						{
							case 'panels':
								$wrapper = $panels;
								break;

							default:
								$wrapper = $panels.filter( opts.addTo );
								break;
						}

						$('.' + _c.divider, $wrapper).remove();

						$wrapper
							.find( '.' + _c.listview )
							.not( '.' + _c.vertical )
							.each(
								function()
								{
									var last = '';
									that.__filterListItems( $(this).children() )
										.each(
											function()
											{
												var crnt = $.trim( $(this).children( 'a, span' ).text() ).slice( 0, 1 ).toLowerCase();
												if ( crnt != last && crnt.length )
												{
													last = crnt;
													$( '<li class="' + _c.divider + '">' + crnt + '</li>' ).insertBefore( this );
												}
											}
										);
								}
							);
					}
				);
			}


			//	Toggle collapsed list items
			if ( opts.collapse )
			{
				this.bind( 'initPanels',
					function( $panels )
					{
						$('.' + _c.divider, $panels )
							.each(
								function()
								{
									var $l = $(this),
										$e = $l.nextUntil( '.' + _c.divider, '.' + _c.collapsed );

									if ( $e.length )
									{
										if ( !$l.children( '.' + _c.subopen ).length )
										{
											$l.wrapInner( '<span />' );
											$l.prepend( '<a href="#" class="' + _c.subopen + ' ' + _c.fullsubopen + '" />' );
										}
									}
								}
							);
					}
				);
			}
			

			//	Fixed dividers
			if ( opts.fixed )
			{
				var update = function( $panl )
				{
					$panl = $panl || this.$pnls.children( '.' + _c.current );
					var $dvdr = $panl
						.find( '.' + _c.divider )
						.not( '.' + _c.hidden );

					if ( $dvdr.length )
					{
						this.$menu.addClass( _c.hasdividers );

						var scrl = $panl.scrollTop() || 0,
							text = '';

						if ( $panl.is( ':visible' ) )
						{
							$panl
								.find( '.' + _c.divider )
								.not( '.' + _c.hidden )
								.each(
									function()
									{
										if ( $(this).position().top + scrl < scrl + 1 )
										{
											text = $(this).text();
										}
									}
								);
						}
	
						this.$fixeddivider.text( text );
					}
					else
					{
						this.$menu.removeClass( _c.hasdividers );
					}
				};


				//	Add the fixed divider
				this.$fixeddivider = $('<ul class="' + _c.listview + ' ' + _c.fixeddivider + '"><li class="' + _c.divider + '"></li></ul>')
					.prependTo( this.$pnls )
					.children();


				//	Set correct value after opening panels and update
				this.bind( 'openPanel', update );
				this.bind( 'update', update );


				//	Set correct value after scrolling
				this.bind( 'initPanels',
					function( $panels )
					{
						$panels
							.off( _e.scroll + '-dividers ' + _e.touchmove + '-dividers' )
							.on( _e.scroll + '-dividers ' + _e.touchmove + '-dividers',
								function( e )
								{
									update.call( that, $(this) );
								}
							);
					}
				);

			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;
	
			_c.add( 'collapsed uncollapsed fixeddivider hasdividers' );
			_e.add( 'scroll' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu )
		{
			if ( this.opts[ _ADDON_ ].collapse && inMenu )
			{
				var $l = $a.parent();
				if ( $l.is( '.' + _c.divider ) )
				{
					var $e = $l.nextUntil( '.' + _c.divider, '.' + _c.collapsed );
			
					$l.toggleClass( _c.opened );
					$e[ $l.hasClass( _c.opened ) ? 'addClass' : 'removeClass' ]( _c.uncollapsed );
					
					return true;
				}
			}
			return false;
		}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		add			: false,
		addTo		: 'panels',
		fixed		: false,
		collapse	: false
	};
	$[ _PLUGIN_ ].configuration.classNames[ _ADDON_ ] = {
		collapsed: 'Collapsed'
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu drag add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'drag';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			if ( !this.opts.offCanvas )
			{
				return;
			}

			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					menu 	: opts,
					panels 	: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			if ( typeof opts.menu == 'boolean' )
			{
				opts.menu = {
					open 	: opts.menu
				};
			}
			if ( typeof opts.menu != 'object' )
			{
				opts.menu = {};
			}
			if ( typeof opts.panels == 'boolean' )
			{
				opts.panels = {
					close 	: opts.panels
				};
			}
			if ( typeof opts.panels != 'object' )
			{
				opts.panels = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			//	Drag open the menu
			if ( opts.menu.open )
			{
				dragOpenMenu.call( this, opts.menu, conf.menu, glbl );
			}

			//	Drag close panels
			if ( opts.panels.close )
			{
				this.bind( 'initPanels',
					function( $panels )
					{
						dragClosePanels.call( this, $panels, opts.panels, conf.panels, glbl );
					}
				);
			}
		},

		//	add: fired once per page load
		add: function()
		{
			if ( typeof Hammer != 'function' || Hammer.VERSION < 2 )
			{
				$[ _PLUGIN_ ].addons[ _ADDON_ ].setup = function() {};
				return;
			}

			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

			_c.add( 'dragging' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		menu 	: {
			open 	: false,
	//		node	: null,
			maxStartPos	: 100,
			threshold	: 50
		},
		panels 	: {
			close 	: false
		},
		vendors	: {
			hammer	: {}
		}
	};
	$[ _PLUGIN_ ].configuration[ _ADDON_ ] = {
		menu : {
			width	: {
				perc	: 0.8,
				min		: 140,
				max		: 440
			},
			height	: {
				perc	: 0.8,
				min		: 140,
				max		: 880
			}
		},
		panels : {}
	};


	var _c, _d, _e, glbl;


	function minMax( val, min, max )
	{
		if ( val < min )
		{
			val = min;
		}
		if ( val > max )
		{
			val = max;
		}
		return val;
	}

	function dragOpenMenu( opts, conf, glbl )
	{
		//	Set up variables
		var that 			= this,
			drag			= {},
			_stage 			= 0,
			_direction 		= false,
			_dimension		= false,
			_distance 		= 0,
			_maxDistance 	= 0;

		var new_distance, drag_distance, css_value,
			doPanstart, getSlideNodes;

		switch( this.opts.offCanvas.position )
		{
			case 'left':
			case 'right':
				drag.events		= 'panleft panright';
				drag.typeLower	= 'x';
				drag.typeUpper	= 'X';
				
				_dimension		= 'width';
				break;

			case 'top':
			case 'bottom':
				drag.events		= 'panup pandown';
				drag.typeLower	= 'y';
				drag.typeUpper	= 'Y';

				_dimension = 'height';
				break;
		}

		switch( this.opts.offCanvas.position )
		{	
			case 'right':
			case 'bottom':
				drag.negative 	= true;
				doPanstart		= function( pos )
				{
					if ( pos >= glbl.$wndw[ _dimension ]() - opts.maxStartPos )
					{
						_stage = 1;
					}
				};
				break;

			default:
				drag.negative 	= false;
				doPanstart		= function( pos )
				{
					if ( pos <= opts.maxStartPos )
					{
						_stage = 1;
					}
				};
				break;
		}

		switch( this.opts.offCanvas.position )
		{
			case 'left':
				drag.open_dir 	= 'right';
				drag.close_dir 	= 'left';
				break;

			case 'right':
				drag.open_dir 	= 'left';
				drag.close_dir 	= 'right';
				break;

			case 'top':
				drag.open_dir 	= 'down';
				drag.close_dir 	= 'up';
				break;

			case 'bottom':
				drag.open_dir 	= 'up';
				drag.close_dir 	= 'down';
				break;
		}

		switch ( this.opts.offCanvas.zposition )
		{
			case 'front':
				getSlideNodes = function()
				{
					return this.$menu;
				};
				break;

			default:
				getSlideNodes = function()
				{
					return $('.' + _c.slideout);
				};
				break;
		}

		var $dragNode = this.__valueOrFn( opts.node, this.$menu, glbl.$page );

		if ( typeof $dragNode == 'string' )
		{
			$dragNode = $($dragNode);
		}


		//	Bind events
		var _hammer = new Hammer( $dragNode[ 0 ], this.opts[ _ADDON_ ].vendors.hammer );

		_hammer
			.on( 'panstart',
				function( e )
				{
					doPanstart( e.center[ drag.typeLower ] );
					glbl.$slideOutNodes = getSlideNodes();
					_direction = drag.open_dir;
				}
			)
			.on( drag.events + ' panend',
				function( e )
				{
					if ( _stage > 0 )
					{
						e.preventDefault();
					}
				}
			)
			.on( drag.events,
				function( e )
				{

					new_distance = e[ 'delta' + drag.typeUpper ];
					if ( drag.negative )
					{
						new_distance = -new_distance;
					}

					if ( new_distance != _distance )
					{
						_direction = ( new_distance >= _distance ) ? drag.open_dir : drag.close_dir;
					}

					_distance = new_distance;

					if ( _distance > opts.threshold )
					{
						if ( _stage == 1 )
						{
							if ( glbl.$html.hasClass( _c.opened ) )
							{
								return;
							}
							_stage = 2;

							that._openSetup();
							that.trigger( 'opening' );
							glbl.$html.addClass( _c.dragging );

							_maxDistance = minMax( 
								glbl.$wndw[ _dimension ]() * conf[ _dimension ].perc, 
								conf[ _dimension ].min, 
								conf[ _dimension ].max
							);
						}
					}
					if ( _stage == 2 )
					{
						drag_distance = minMax( _distance, 10, _maxDistance ) - ( that.opts.offCanvas.zposition == 'front' ? _maxDistance : 0 );
						if ( drag.negative )
						{
							drag_distance = -drag_distance;
						}
						css_value = 'translate' + drag.typeUpper + '(' + drag_distance + 'px )';

						glbl.$slideOutNodes.css({
							'-webkit-transform': '-webkit-' + css_value,	
							'transform': css_value
						});
					}
				}
			)
			.on( 'panend',
				function( e )
				{
					if ( _stage == 2 )
					{
						glbl.$html.removeClass( _c.dragging );
						glbl.$slideOutNodes.css( 'transform', '' );
						that[ _direction == drag.open_dir ? '_openFinish' : 'close' ]();
					}
		        	_stage = 0;
			    }
			);
	}


	function dragClosePanels( $panels, opts, conf, glbl )
	{
		var that = this;

		//	Bind events
		$panels.each(
			function()
			{
				var $panl = $(this),
					$prnt = $panl.data( _d.parent );

				if ( $prnt )
				{
					$prnt = $prnt.closest( '.' + _c.panel );

					if ( $prnt.length )
					{
						var _hammer = new Hammer( $panl[ 0 ], that.opts[ _ADDON_ ].vendors.hammer );
						_hammer
							.on( 'panright',
								function( e )
								{
									that.openPanel( $prnt );
								}
							);
					}
				}
			}
		);
	}

})( jQuery );
/*	
 * jQuery mmenu dropdown add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'dropdown';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			if ( !this.opts.offCanvas )
			{
				return;
			}

			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' && opts )
			{
				opts = {
					drop: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			if ( typeof opts.position == 'string' )
			{
				opts.position = {
					of: opts.position
				};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			if ( !opts.drop )
			{
				return;
			}


			if ( typeof opts.position.of != 'string' )
			{
				var id = this.$menu.attr( 'id' );
				if ( id && id.length )
				{
					if ( this.conf.clone )
					{
						id = _c.umm( id );
					}
					opts.position.of = '[href="#' + id + '"]';
				}
			}
			if ( typeof opts.position.of != 'string' )
			{
				return;
			}


			//	Get the button to put the menu next to
			var $bttn = $(opts.position.of);
			if ( !$bttn.length )
			{
				return;
			}

			this.$menu.addClass( _c.dropdown );

			if ( opts.tip )
			{
				this.$menu.addClass( _c.tip );
			}


			//	Emulate hover effect
			opts.event = opts.event.split( ' ' );
			if ( opts.event.length == 1 )
			{
				opts.event[ 1 ] = opts.event[ 0 ];
			}
			if ( opts.event[ 0 ] == 'hover' )
			{
				$bttn
					.on( _e.mouseenter + '-dropdown',
						function()
						{
							that.open();
						}
					);
			}
			if ( opts.event[ 1 ] == 'hover' )
			{
				this.$menu
					.on( _e.mouseleave + '-dropdown',
						function()
						{
							that.close();
						}
					);
			}


			//	Add/remove classname and style when opening/closing the menu
			this.bind( 'opening',
				function()
				{
					this.$menu.data( _d.style, this.$menu.attr( 'style' ) || '' );
					glbl.$html.addClass( _c.dropdown );
				}
			);

			this.bind( 'closed',
				function()
				{
					this.$menu.attr( 'style', this.$menu.data( _d.style ) );
					glbl.$html.removeClass( _c.dropdown );
				}
			);


			//	Update the position and sizes
			var getPosition = function( dir, obj )
			{
				var css = obj[ 0 ],
					cls = obj[ 1 ];

				var _scr = dir == 'x' ? 'scrollLeft' 	: 'scrollTop',
					_out = dir == 'x' ? 'outerWidth' 	: 'outerHeight',
					_str = dir == 'x' ? 'left' 			: 'top',
					_stp = dir == 'x' ? 'right' 		: 'bottom',
					_siz = dir == 'x' ? 'width' 		: 'height',
					_max = dir == 'x' ? 'maxWidth' 		: 'maxHeight',
					_pos = null;

				var scrl = glbl.$wndw[ _scr ](),
					strt = $bttn.offset()[ _str ] -= scrl,
					stop = strt + $bttn[ _out ](),
					wndw = glbl.$wndw[ _siz ]();

				var offs = conf.offset.button[ dir ] + conf.offset.viewport[ dir ];

				//	Position set in option
				if ( opts.position[ dir ] )
				{
					switch ( opts.position[ dir ] )
					{
						case 'left':
						case 'bottom':
							_pos = 'after';
							break;

						case 'right':
						case 'top':
							_pos = 'before';
							break;
					}
				}

				//	Position not set in option, find most space
				if ( _pos === null )
				{
					_pos = ( strt + ( ( stop - strt ) / 2 ) < wndw / 2 ) ? 'after' : 'before';
				}

				//	Set position and max
				var val, max;
				if ( _pos == 'after' )
				{
					val = ( dir == 'x' ) ? strt : stop;
					max = wndw - ( val + offs );

					css[ _str ] = val + conf.offset.button[ dir ];
					css[ _stp ] = 'auto';

					cls.push( _c[ ( dir == 'x' ) ? 'tipleft' : 'tiptop' ] );
				}
				else
				{
					val = ( dir == 'x' ) ? stop : strt;
					max = val - offs;

					css[ _stp ] = 'calc( 100% - ' + ( val - conf.offset.button[ dir ] ) + 'px )';
					css[ _str ] = 'auto';

					cls.push( _c[ ( dir == 'x' ) ? 'tipright' : 'tipbottom' ] );
				}

				css[ _max ] = Math.min( $[ _PLUGIN_ ].configuration[ _ADDON_ ][ _siz ].max, max );

				return [ css, cls ];
			};
			var position = function( $panl )
			{
				if ( !this.vars.opened )
				{
					return;
				}

				this.$menu.attr( 'style', this.$menu.data( _d.style ) );

				var obj = [{}, []];
				obj = getPosition.call( this, 'y', obj );
				obj = getPosition.call( this, 'x', obj );

				this.$menu.css( obj[ 0 ] );

				if ( opts.tip )
				{
					this.$menu
						.removeClass( 
							_c.tipleft 	+ ' ' +
							_c.tipright	+ ' ' + 
							_c.tiptop 	+ ' ' +
							_c.tipbottom
						)
						.addClass( obj[ 1 ].join( ' ' ) );
				}
			};

			this.bind( 'opening', position );

			glbl.$wndw
				.on( _e.resize + '-dropdown',
					function( e )
					{
						position.call( that );
					}
				);

			if ( !this.opts.offCanvas.blockUI )
			{
				glbl.$wndw
					.on( _e.scroll + '-dropdown',
						function( e )
						{
							position.call( that );
						}
					);
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

 			_c.add( 'dropdown tip tipleft tipright tiptop tipbottom' );
 			_e.add( 'mouseenter mouseleave resize scroll' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		drop 		: false,
		event		: 'click',
		position	: {},
		tip			: true
	};
	$[ _PLUGIN_ ].configuration[ _ADDON_ ] = {
		offset: {
			button	: {
				x 		: -10,
				y		: 10
			},
			viewport: {
				x 		: 20,
				y 		: 20
			}
		},
		height	: {
			max		: 880
		},
		width	: {
			max		: 440
		}
	};


	var _c, _d, _e, glbl;


})( jQuery );
/*	
 * jQuery mmenu fixedElements add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'fixedElements';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			if ( !this.opts.offCanvas )
			{
				return;
			}

			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );

			var setPage = function( $page )
			{
				//	Refactor fixed classes
				var _fixd = this.conf.classNames[ _ADDON_ ].fixed;

				this.__refactorClass( $page.find( '.' + _fixd ), _fixd, 'slideout' )
					.appendTo( glbl.$body );
			};
			setPage.call( this, glbl.$page );
			this.bind( 'setPage', setPage );
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;
	
			_c.add( 'fixed' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].configuration.classNames[ _ADDON_ ] = {
		fixed 	: 'Fixed'
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu iconPanels add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'iconPanels';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					add 	: opts
				};
			}
			if ( typeof opts == 'number' )
			{
				opts = {
					add 	: true,
					visible : opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );
			opts.visible++;


			//	Add the iconbars
			if ( opts.add )
			{

				this.$menu.addClass( _c.iconpanel );

				var clsn = [];
				for ( var i = 0; i <= opts.visible; i++ )
				{
					clsn.push( _c.iconpanel + '-' + i );
				}
				clsn = clsn.join( ' ' );

				var update = function( $panel )
				{
					if ( $panel.hasClass( _c.vertical ) )
					{
						return;
					}

					that.$pnls
						.children( '.' + _c.panel )
						.removeClass( clsn )
						.filter( '.' + _c.subopened )
						.removeClass( _c.hidden )
						.add( $panel )
						.not( '.' + _c.vertical )
						.slice( -opts.visible )
						.each(
							function( x )
							{
								$(this).addClass( _c.iconpanel + '-' + x );
							}
						);
				};

				this.bind( 'openPanel', update );
				this.bind( 'initPanels',
					function( $panels )
					{
						update.call( that, that.$pnls.children( '.' + _c.current ) );

						$panels
							.not( '.' + _c.vertical )
							.each(
								function()
								{
									if ( !$(this).children( '.' + _c.subblocker ).length )
									{
										$(this).prepend( '<a href="#' + $(this).closest( '.' + _c.panel ).attr( 'id' ) + '" class="' + _c.subblocker + '" />' );
									}
								}
							);
					}
				);
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;
	
			_c.add( 'iconpanel subblocker' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		add 		: false,
		visible		: 3
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu keyboardNavigation add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'keyboardNavigation';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' || typeof opts == 'string' )
			{
				opts = {
					enable: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			//	Enable keyboard navigation
			if ( opts.enable )
			{

				if ( opts.enhance )
				{
					this.$menu.addClass( _c.keyboardfocus );
				}

				var $start = $('<input class="' + _c.tabstart + '" tabindex="0" type="text" />'),
					$end   = $('<input class="' + _c.tabend   + '" tabindex="0" type="text" />');

				this.bind( 'initPanels',
					function()
					{
						this.$menu
							.prepend( $start )
							.append(  $end )
							.children( '.' + _c.navbar )
								.find( focs )
								.attr( 'tabindex', 0 );
					}
				);

				this.bind( 'open',
					function()
					{
						tabindex.call( this );

						this.__transitionend( this.$menu,
							function()
							{
								focus.call( that, null, opts.enable );
							}, this.conf.transitionDuration
						);
					}
				);

				this.bind( 'openPanel',
					function( $panl )
					{
						tabindex.call( this, $panl );

						this.__transitionend( $panl,
							function()
							{
								focus.call( that, $panl, opts.enable );
							}, this.conf.transitionDuration
						);
					}
				);

				this[ '_initWindow_' + _ADDON_ ]( opts.enhance );
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

			_c.add( 'tabstart tabend keyboardfocus' );
			_e.add( 'focusin keydown' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		enable: false,
		enhance: false
	};
	$[ _PLUGIN_ ].configuration[ _ADDON_ ] = {};


	//	Methods
	$[ _PLUGIN_ ].prototype[ '_initWindow_' + _ADDON_ ] = function( enhance )
	{

		//	Re-enable tabbing in general
		glbl.$wndw
			.off( _e.keydown + '-offCanvas' );

		//	Prevent tabbing outside an offcanvas menu
		glbl.$wndw
			.off( _e.focusin + '-' + _ADDON_ )
			.on( _e.focusin + '-' + _ADDON_,
				function( e ) 
				{
					if ( glbl.$html.hasClass( _c.opened ) )
					{
						var $t = $(e.target);

						if ( $t.is( '.' + _c.tabend ) )
						{
							$t.parent().find( '.' + _c.tabstart ).focus();
						}
					}
				}
			);

		//	Default keyboard navigation
		glbl.$wndw
			.off( _e.keydown + '-' + _ADDON_ )
			.on( _e.keydown + '-' + _ADDON_,
				function( e )
				{
					var $t = $(e.target),
						$m = $t.closest( '.' + _c.menu );

					if ( $m.length )
					{
						var api = $m.data( 'mmenu' );

						//	special case for input and textarea
						if ( $t.is( 'input, textarea' ) )
						{
						}
						else
						{
							switch( e.keyCode )
							{
								//	press enter to toggle and check
								case 13: 
									if ( $t.is( '.mm-toggle' ) || 
										 $t.is( '.mm-check' )
									) {
										$t.trigger( _e.click );
									}
									break;

								//	prevent spacebar or arrows from scrolling the page
								case 32: 	//	space
								case 37: 	//	left
								case 38: 	//	top
								case 39: 	//	right
								case 40: 	//	bottom
									e.preventDefault();
									break;
							}
						}
					}
				}
			);

		//	Enhanced keyboard navigation
		if ( enhance )
		{
			glbl.$wndw
				.on( _e.keydown + '-' + _ADDON_,
					function( e )
					{
						var $t = $(e.target),
							$m = $t.closest( '.' + _c.menu );

						if ( $m.length )
						{
							var api = $m.data( 'mmenu' );

							//	special case for input and textarea
							if ( $t.is( 'input, textarea' ) )
							{
								switch( e.keyCode )
								{
									//	empty searchfield with esc
									case 27:
										$t.val( '' );
										break;
								}
							}
							else
							{
								switch( e.keyCode )
								{
									//	close submenu with backspace
									case 8: 
										var $p = $t.closest( '.' + _c.panel ).data( _d.parent );
										if ( $p && $p.length )
										{
											api.openPanel( $p.closest( '.' + _c.panel ) );
										}
										break;

									//	close menu with esc
									case 27:
										if ( $m.hasClass( _c.offcanvas ) )
										{
											api.close();
										}
										break;
								}
							}
						}
					}
				);
		}
	};

	var _c, _d, _e, glbl;
	var focs = 'input, select, textarea, button, label, a[href]';


	function focus( $panl, enable )
	{
		if ( !$panl )
		{
			$panl = this.$pnls.children( '.' + _c.current );
		}

		var $focs = $();

		if ( enable == 'default' )
		{
			//	first anchor in listview
			$focs = $panl.children( '.' + _c.listview ).find( 'a[href]' ).not( ':hidden' );

			//	first element in panel
			if ( !$focs.length )
			{
				$focs = $panl.find( focs ).not( ':hidden' );
			}

			//	first anchor in navbar
			if ( !$focs.length )
			{
				$focs = this.$menu.children( '.' + _c.navbar ).find( focs ).not( ':hidden' );
			}
		}

		//	default
		if ( !$focs.length )
		{
			$focs = this.$menu.children( '.' + _c.tabstart );
		}

		$focs.first().focus();
	}
	function tabindex( $panl )
	{
		if ( !$panl )
		{
			$panl = this.$pnls.children( '.' + _c.current );
		}

		var $pnls = this.$pnls.children( '.' + _c.panel ),
			$hidn = $pnls.not( $panl );

		$hidn.find( focs ).attr( 'tabindex', -1 );
		$panl.find( focs ).attr( 'tabindex', 0 );

		//	_c.toggle will result in an empty string if the toggle addon is not loaded
		$panl.find( 'input.mm-toggle, input.mm-check' ).attr( 'tabindex', -1 );
	}

})( jQuery );
/*	
 * jQuery mmenu lazySubmenus add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'lazySubmenus';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					load: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			//	Sliding submenus
			if ( opts.load )
			{
				this.$menu
					.find( 'li' )
					.find( 'li' )
					.children( this.conf.panelNodetype )
					.each(
						function()
						{
							$(this)
								.parent()
								.addClass( _c.lazysubmenu )
								.data( _d.lazysubmenu, this )
								.end()
								.remove();
						}
					);

				this.bind( 'openingPanel',
					function( $panl )
					{
						var $prnt = $panl.find( '.' + _c.lazysubmenu );
						if ( $prnt.length )
						{
							$prnt.each(
								function()
								{
									$(this)
										.append( $(this).data( _d.lazysubmenu ) )
										.removeData( _d.lazysubmenu )
										.removeClass( _c.lazysubmenu );
								}
							);

							this.initPanels( $panl );
						}
					}
				);
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

			_c.add( 'lazysubmenu' );
			_d.add( 'lazysubmenu' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		load: false
	};
	$[ _PLUGIN_ ].configuration[ _ADDON_ ] = {};


	var _c, _d, _e, glbl;


})( jQuery );
/*	
 * jQuery mmenu navbar add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'navbars';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				navs = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;

			if ( typeof navs == 'undefined' )
			{
				return;
			}

			if ( !( navs instanceof Array ) )
			{
				navs = [ navs ];
			}

			var _pos = {};

			if ( !navs.length )
			{
				return;
			}

			$.each(
				navs,
				function( n )
				{
				
					var opts = navs[ n ];

					//	Extend shorthand options
					if ( typeof opts == 'boolean' && opts )
					{
						opts = {};
					}
					if ( typeof opts != 'object' )
					{
						opts = {};
					}
					if ( typeof opts.content == 'undefined' )
					{
						opts.content = [ 'prev', 'title' ];
					}
					if ( !( opts.content instanceof Array ) )
					{
						opts.content = [ opts.content ];
					}
					opts = $.extend( true, {}, that.opts.navbar, opts );


					//	Get position and height
					var poss = opts.position,
						hght = opts.height;

					if ( typeof hght != 'number' )
					{
						hght = 1;
					}
					hght = Math.min( 4, Math.max( 1, hght ) );

					if ( poss != 'bottom' )
					{
						poss = 'top';
					}
					if ( !_pos[ poss ] )
					{
						_pos[ poss ] = 0;
					}
					_pos[ poss ]++;


					//	Add markup
					var $navbar = $( '<div />' )
						.addClass( 
							_c.navbar + ' ' +
							_c.navbar + '-' + poss + ' ' +
							_c.navbar + '-' + poss + '-' + _pos[ poss ] + ' ' +
							_c.navbar + '-size-' + hght
						);

					_pos[ poss ] += hght - 1;

					var _content = 0;
					for ( var c = 0, l = opts.content.length; c < l; c++ )
					{
						var ctnt = $[ _PLUGIN_ ].addons[ _ADDON_ ][ opts.content[ c ] ] || false;
						if ( ctnt )
						{
							_content += ctnt.call( that, $navbar, opts, conf );
						}
						else
						{
							ctnt = opts.content[ c ];
							if ( !( ctnt instanceof $ ) )
							{
								ctnt = $( opts.content[ c ] );
							}
							$navbar.append( ctnt );
						}
					}

					_content += Math.ceil( $navbar.children().not( '.' + _c.btn ).length / hght );
					if ( _content > 1 )
					{
						$navbar.addClass( _c.navbar + '-content-' + _content );
					}
					if ( $navbar.children( '.' + _c.btn ).length )
					{
						$navbar.addClass( _c.hasbtns );
					}
					$navbar.prependTo( that.$menu );
				}
			);

			for ( var poss in _pos )
			{
				that.$menu.addClass( _c.hasnavbar + '-' + poss + '-' + _pos[ poss ] );
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

			_c.add( 'close hasbtns' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].configuration[ _ADDON_ ] = {
		breadcrumbSeparator: '/'
	};
	$[ _PLUGIN_ ].configuration.classNames[ _ADDON_ ] = {};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu navbar add-on breadcrumbs content
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ 	= 'mmenu',
		_ADDON_  	= 'navbars',
		_CONTENT_	= 'breadcrumbs';

	$[ _PLUGIN_ ].addons[ _ADDON_ ][ _CONTENT_ ] = function( $navbar, opts, conf )
	{
		//	Get vars
		var _c = $[ _PLUGIN_ ]._c,
			_d = $[ _PLUGIN_ ]._d;

		_c.add( 'breadcrumbs separator' );


		//	Add content
		var $crumbs = $('<span class="' + _c.breadcrumbs + '" />').appendTo( $navbar );
		this.bind( 'initPanels',
			function( $panels )
			{
				$panels
					.removeClass( _c.hasnavbar )
					.each(
						function()
						{
							var crumbs = [],
								$panl = $(this),
								$bcrb = $( '<span class="' + _c.breadcrumbs + '"></span>' ),
								$crnt = $(this).children().first(),
								first = true;

							while ( $crnt && $crnt.length )
							{
								if ( !$crnt.is( '.' + _c.panel ) )
								{
									$crnt = $crnt.closest( '.' + _c.panel );
								}

								var text = $crnt.children( '.' + _c.navbar ).children( '.' + _c.title ).text();
								crumbs.unshift( first ? '<span>' + text + '</span>' : '<a href="#' + $crnt.attr( 'id' ) + '">' + text + '</a>' );

								first = false;
								$crnt = $crnt.data( _d.parent );
							}
							$bcrb
								.append( crumbs.join( '<span class="' + _c.separator + '">' + conf.breadcrumbSeparator + '</span>' ) )
								.appendTo( $panl.children( '.' + _c.navbar ) );
						}
					);
			}
		);


		//	Update
		var update = function()
		{
			$crumbs.html( 
				this.$pnls
					.children( '.' + _c.current )
					.children( '.' + _c.navbar )
					.children( '.' + _c.breadcrumbs )
					.html()
			);
		};

		this.bind( 'openPanel', update );
		this.bind( 'initPanels', update );


		//	Maintain content count
		return 0;
	};

})( jQuery );
/*	
 * jQuery mmenu navbar add-on close content
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ 	= 'mmenu',
		_ADDON_  	= 'navbars',
		_CONTENT_	= 'close';

	$[ _PLUGIN_ ].addons[ _ADDON_ ][ _CONTENT_ ] = function( $navbar, opts )
	{
		//	Get vars
		var _c = $[ _PLUGIN_ ]._c,
			glbl = $[ _PLUGIN_ ].glbl;


		//	Add content
		var $close = $('<a class="' + _c.close + ' ' + _c.btn + '" href="#" />').appendTo( $navbar );


		//	Update
		var setPage = function( $page )
		{
			$close.attr( 'href', '#' + $page.attr( 'id' ) );
		};
		setPage.call( this, glbl.$page );
		this.bind( 'setPage', setPage );


		//	Detract content count
		return -1;
	};

})( jQuery );
/*
 * jQuery mmenu navbar add-on next content
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ 	= 'mmenu',
		_ADDON_  	= 'navbars',
		_CONTENT_	= 'next';

	$[ _PLUGIN_ ].addons[ _ADDON_ ][ _CONTENT_ ] = function( $navbar, opts )
	{
		//	Get vars
		var _c = $[ _PLUGIN_ ]._c;


		//	Add content
		var $next = $('<a class="' + _c.next + ' ' + _c.btn + '" href="#" />').appendTo( $navbar );


		//	Update
		var _url, _txt, _own;

		var update = function( $panel )
		{
			$panel = $panel || this.$pnls.children( '.' + _c.current );

			var $orgn = $panel.find( '.' + this.conf.classNames[ _ADDON_ ].panelNext );

			_url = $orgn.attr( 'href' );
			_own = $orgn.attr( 'aria-owns' );
			_txt = $orgn.html();

			$next[ _url ? 'attr' : 'removeAttr' ]( 'href', _url );
			$next[ _own ? 'attr' : 'removeAttr' ]( 'aria-owns', _own );
			$next[ _url || _txt ? 'removeClass' : 'addClass' ]( _c.hidden );
			$next.html( _txt );
		};

		this.bind( 'openPanel', update );
		this.bind( 'initPanels',
			function()
			{
				update.call( this );
			}
		);

		//	Detract content count
		return -1;
	};

	$[ _PLUGIN_ ].configuration.classNames[ _ADDON_ ].panelNext	= 'Next';

})( jQuery );

/*
 * jQuery mmenu navbar add-on prev content
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ 	= 'mmenu',
		_ADDON_  	= 'navbars',
		_CONTENT_	= 'prev';

	$[ _PLUGIN_ ].addons[ _ADDON_ ][ _CONTENT_ ] = function( $navbar, opts )
	{
		//	Get vars
		var _c = $[ _PLUGIN_ ]._c;


		//	Add content
		var $prev = $('<a class="' + _c.prev + ' ' + _c.btn + '" href="#" />').appendTo( $navbar );

		this.bind( 'initPanels',
			function( $panl )
			{
				$panl
					.removeClass( _c.hasnavbar )
					.children( '.' + _c.navbar )
					.addClass( _c.hidden );
			}
		);


		//	Update
		var _url, _txt, _own;

		var update = function( $panel )
		{
			$panel = $panel || this.$pnls.children( '.' + _c.current );
			if ( $panel.hasClass( _c.vertical ) )
			{
				return;
			}

			var $orgn = $panel.find( '.' + this.conf.classNames[ _ADDON_ ].panelPrev );
			if ( !$orgn.length )
			{
				$orgn = $panel.children( '.' + _c.navbar ).children( '.' + _c.prev );
			}

			_url = $orgn.attr( 'href' );
			_own = $orgn.attr( 'aria-owns' );
			_txt = $orgn.html();

			$prev[ _url ? 'attr' : 'removeAttr' ]( 'href', _url );
			$prev[ _own ? 'attr' : 'removeAttr' ]( 'aria-owns', _own );
			$prev[ _url || _txt ? 'removeClass' : 'addClass' ]( _c.hidden );
			$prev.html( _txt );
		};

		this.bind( 'openPanel', update );
		this.bind( 'initPanels',
			function()
			{
				update.call( this );
			}
		);


		//	Detract content count
		return -1;
	};

	$[ _PLUGIN_ ].configuration.classNames[ _ADDON_ ].panelPrev = 'Prev';

})( jQuery );

/*	
 * jQuery mmenu navbar add-on searchfield content
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ 	= 'mmenu',
		_ADDON_  	= 'navbars',
		_CONTENT_	= 'searchfield';

	$[ _PLUGIN_ ].addons[ _ADDON_ ][ _CONTENT_ ] = function( $navbar, opts )
	{
		var _c = $[ _PLUGIN_ ]._c;

		var $srch = $('<div class="' + _c.search + '" />')
			.appendTo( $navbar );

		if ( typeof this.opts.searchfield != 'object' )
		{
			this.opts.searchfield = {};
		}
		this.opts.searchfield.add = true;
		this.opts.searchfield.addTo = $srch;


		//	Maintain content count
		return 0;
	};

})( jQuery );
/*	
 * jQuery mmenu navbar add-on title content
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ 	= 'mmenu',
		_ADDON_  	= 'navbars',
		_CONTENT_	= 'title';

	$[ _PLUGIN_ ].addons[ _ADDON_ ][ _CONTENT_ ] = function( $navbar, opts )
	{
		//	Get vars
		var _c = $[ _PLUGIN_ ]._c;


		//	Add content
		var $title = $('<a class="' + _c.title + '" />').appendTo( $navbar );


		//	Update
		var _url, _txt;

		var update = function( $panel )
		{
			$panel = $panel || this.$pnls.children( '.' + _c.current );
			if ( $panel.hasClass( _c.vertical ) )
			{
				return;
			}

			var $orgn = $panel.find( '.' + this.conf.classNames[ _ADDON_ ].panelTitle );
			if ( !$orgn.length )
			{
				$orgn = $panel.children( '.' + _c.navbar ).children( '.' + _c.title );
			}

			_url = $orgn.attr( 'href' );
			_txt = $orgn.html() || opts.title;

			$title[ _url ? 'attr' : 'removeAttr' ]( 'href', _url );
			$title[ _url || _txt ? 'removeClass' : 'addClass' ]( _c.hidden );
			$title.html( _txt );
		};

		this.bind( 'openPanel', update );
		this.bind( 'initPanels',
			function( $panels )
			{
				update.call( this );
			}
		);


		//	Maintain content count
		return 0;
	};

	$[ _PLUGIN_ ].configuration.classNames[ _ADDON_ ].panelTitle = 'Title';

})( jQuery );
/*	
 * jQuery mmenu RTL add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'rtl';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts != 'object' )
			{
				opts = {
					use: opts
				};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );

			//	Autodetect
			if ( typeof opts.use != 'boolean' )
			{
				opts.use = ( ( glbl.$html.attr( 'dir' ) || '' ).toLowerCase() == 'rtl' );
			}

			//	Use RTL
			if ( opts.use )
			{
				this.$menu.addClass( _c.rtl );
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;
	
			_c.add( 'rtl' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		use: 'detect'
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*
 * jQuery mmenu screenReader add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'screenReader';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					aria: opts,
					text: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			//	Aria
			if ( opts.aria )
			{
				//	Apply aria-hidden to menu when closed
				if ( this.opts.offCanvas )
				{
					var aria_open = function()
					{
						aria_value( this.$menu, 'hidden', false );
					};
					var aria_close = function()
					{
						aria_value( this.$menu, 'hidden', true );
					};
					this.bind( 'open'	, aria_open );
					this.bind( 'close'	, aria_close );

					aria_value( this.$menu, 'hidden', true );
				}

				//	Apply aria-hidden to hidden content
				var aria_update = function()
				{
					//	TODO, unfortunately, aria-hidden is not per se non-visible
					//	Searchfield add-on will need this to work
					//	Maybe LI's only?
//					aria_value( this.$menu.find( '.' + _c.hidden ), 'hidden', true );
				};
				var aria_openPanel = function( $panel )
				{
					var $navb = this.$menu.children( '.' + _c.navbar ),
						$prev = $navb.children( '.' + _c.prev ),
						$next = $navb.children( '.' + _c.next ),
						$titl = $navb.children( '.' + _c.title );

					//	Apply aria-hidden to prev- and next-buttons when hidden
					aria_value( $prev, 'hidden', $prev.is( '.' + _c.hidden ) );
					aria_value( $next, 'hidden', $next.is( '.' + _c.hidden ) );

					//	Apply aria-hidden to the title if the prev-button has screen reader text and is visible
					if ( opts.text )
					{
						aria_value( $titl, 'hidden', !$prev.is( '.' + _c.hidden ) );
					}

					//	Apply aria-hidden to hidden panels
					aria_value( this.$pnls.children( '.' + _c.panel ).not( $panel ), 'hidden', true );
					aria_value( $panel, 'hidden', false );
				};
				this.bind( 'update' 	, aria_update );
				this.bind( 'openPanel' 	, aria_update );
				this.bind( 'openPanel' 	, aria_openPanel );

				var aria_init = function( $panels )
				{
					var $n;

					$panels = $panels || this.$menu;

					var $navb = $panels.children( '.' + _c.navbar ),
						$prev = $navb.children( '.' + _c.prev ),
						$next = $navb.children( '.' + _c.next ),
						$titl = $navb.children( '.' + _c.title );

					//	Apply aria-haspopup to prev- and next-buttons
					aria_value( $prev, 'haspopup', true );
					aria_value( $next, 'haspopup', true );

					//	Apply aria-owns to prev- and next-buttons
					$n = ( $panels.is( '.' + _c.panel ) )
						? $panels.find( '.' + _c.prev + ', .' + _c.next )
						: $prev.add( $next );

					$n.each(
						function()
						{
							aria_value( $(this), 'owns', $(this).attr( 'href' ).replace( '#', '' ) );
						}
					);

					//	Apply aria-hidden to item text if the (full-width-)next-button has screen reader text
					if ( opts.text )
					{
						if ( $panels.is( '.' + _c.panel ) )
						{
							$n = $panels
								.find( '.' + _c.listview )
								.find( '.' + _c.fullsubopen )
								.parent()
								.children( 'span' );

							aria_value( $n, 'hidden', true );
						}
					}
				};
				this.bind( 'initPanels'	, aria_init );
				this.bind( '_initAddons', aria_init );
			}


			//	Text
			if ( opts.text )
			{
				var text_init = function( $panels )
				{
					var $n;

					$panels = $panels || this.$menu;

					var $navb = $panels.children( '.' + _c.navbar );

					//	Apply screen reader text to the prev-button
					$navb
						.each(
							function()
							{
								var $t  = $(this),
									txt = $[ _PLUGIN_ ].i18n( conf.text.closeSubmenu );

								$n = $t.children( '.' + _c.title );
								if ( $n.length )
								{
									txt += ' (' + $n.text() + ')';
								}

								$t.children( '.' + _c.prev )
									.html( text_span( txt ) );
							}
						);

					//	Apply screen reader text to the close-button
					$navb
						.children( '.' + _c.close )
						.html( text_span( $[ _PLUGIN_ ].i18n( conf.text.closeMenu ) ) );

					//	Apply screen reader text to the next-button
					if ( $panels.is( '.' + _c.panel ) )
					{
						$panels
							.find( '.' + _c.listview )
							.children( 'li' )
							.children( '.' + _c.next )
							.each(
								function()
								{
									var $t = $(this),
										txt = $[ _PLUGIN_ ].i18n( conf.text[ $t.parent().is( '.' + _c.vertical ) ? 'toggleSubmenu' : 'openSubmenu' ] );
									
									$n = $t.nextAll( 'span, a' ).first();
									if ( $n.length )
									{
										txt += ' (' + $n.text() + ')';
									}

									$t.html( text_span( txt ) );
								}
							);
					}
				};
				this.bind( 'initPanels'	, text_init );
				this.bind( '_initAddons', text_init );
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

			_c.add( 'sronly' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		aria: false,
		text: false
	};
	$[ _PLUGIN_ ].configuration[ _ADDON_ ] = {
		text: {
			closeMenu       : 'Close menu',
			closeSubmenu    : 'Close submenu',
			openSubmenu     : 'Open submenu',
			toggleSubmenu   : 'Toggle submenu'
		}
	};


	var _c, _d, _e, glbl;

	function aria_value( $elem, attr, value )
	{
		$elem
			.prop( 'aria-' + attr, value )
			[ value ? 'attr' : 'removeAttr' ]( 'aria-' + attr, value );
	}
	function text_span( text )
	{
		return '<span class="' + _c.sronly + '">' + text + '</span>';
	}

})( jQuery );

/*	
 * jQuery mmenu searchfield add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'searchfield';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					add: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			if ( typeof opts.resultsPanel == 'boolean' )
			{
				opts.resultsPanel = {
					add: opts.resultsPanel
				};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );
			conf = this.conf[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].configuration[ _ADDON_ ], conf );


			//	Blur searchfield
			this.bind( 'close',
				function()
				{
					this.$menu
						.find( '.' + _c.search )
						.find( 'input' )
						.blur();
				}
			);


			//	Bind functions to update
			this.bind( 'initPanels',
				function( $panels )
				{

					//	Add the searchfield(s)
					if ( opts.add )
					{
						var $wrapper;
						switch( opts.addTo )
						{
							case 'panels':
								$wrapper = $panels;
								break;

							default:
								$wrapper = this.$menu.find( opts.addTo );
								break;
						}

						$wrapper
							.each(
								function()
								{
									//	Add the searchfield
									var $panl = $(this);
									if ( $panl.is( '.' + _c.panel ) && $panl.is( '.' + _c.vertical ) )
									{
										return;
									}

									if ( !$panl.children( '.' + _c.search ).length )
									{
										var clear  = that.__valueOrFn( conf.clear , $panl ),
											form   = that.__valueOrFn( conf.form  , $panl ),
											input  = that.__valueOrFn( conf.input , $panl ),
											submit = that.__valueOrFn( conf.submit, $panl );

										var $srch = $( '<' + ( form ? 'form' : 'div' ) + ' class="' + _c.search + '" />' ),
											$inpt = $( '<input placeholder="' + $[ _PLUGIN_ ].i18n( opts.placeholder ) + '" type="text" autocomplete="off" />' );

										$srch.append( $inpt );

										var k;

										if ( input )
										{
											for ( k in input )
											{
												$inpt.attr( k, input[ k ] );
											}
										}
										if ( clear )
										{
											$('<a class="' + _c.btn + ' ' + _c.clear + '" href="#" />')
												.appendTo( $srch )
												.on( _e.click + '-searchfield',
													function( e )
													{
														e.preventDefault();
														$inpt
															.val( '' )
															.trigger( _e.keyup + '-searchfield' );
													}
												);
										}
										if ( form )
										{
											for ( k in form )
											{
												$srch.attr( k, form[ k ] );
											}
											if ( submit && !clear )
											{
												$('<a class="' + _c.btn + ' ' + _c.next + '" href="#" />')
													.appendTo( $srch )
													.on( _e.click + '-searchfield',
														function( e )
														{
															e.preventDefault();
															$srch.submit();
														}
													);
											}
										}

										if ( $panl.hasClass( _c.search ) )
										{
											$panl.replaceWith( $srch );
										}
										else
										{
											$panl.prepend( $srch )
												.addClass( _c.hassearch );
										}
									}

									if ( opts.noResults )
									{
										var inPanel = $panl.closest( '.' + _c.panel ).length;

										//	Not in a panel
										if ( !inPanel )
										{
											$panl = that.$pnls.children( '.' + _c.panel ).first();
										}

										//	Add no-results message
										if ( !$panl.children( '.' + _c.noresultsmsg ).length )
										{
											var $lst = $panl.children( '.' + _c.listview ).first();

											$( '<div class="' + _c.noresultsmsg + ' ' + _c.hidden + '" />' )
												.append( $[ _PLUGIN_ ].i18n( opts.noResults ) )
												[ $lst.length ? 'insertAfter' : 'prependTo' ]( $lst.length ? $lst : $panl );
										}
									}
								}
						);


						//	Search through list items
						if ( opts.search )
						{

							if ( opts.resultsPanel.add )
							{
								opts.showSubPanels = false;

								var $rpnl = this.$pnls.children( '.' + _c.resultspanel );
								if ( !$rpnl.length )
								{
									$rpnl = $( '<div class="' + _c.panel + ' ' + _c.resultspanel + ' ' + _c.hidden + '" />' )
										.appendTo( this.$pnls )
										.append( '<div class="' + _c.navbar + ' ' + _c.hidden + '"><a class="' + _c.title + '">' + $[ _PLUGIN_ ].i18n( opts.resultsPanel.title ) + '</a></div>' )
										.append( '<ul class="' + _c.listview + '" />' )
										.append( this.$pnls.find( '.' + _c.noresultsmsg ).first().clone() );

									this.initPanels( $rpnl );
								}
							}

							this.$menu
								.find( '.' + _c.search )
								.each(
									function()
									{
										var $srch 	= $(this),
											inPanel = $srch.closest( '.' + _c.panel ).length;

										var $pnls, $panl;

										//	In a panel
										if ( inPanel )
										{
											$pnls = $srch.closest( '.' + _c.panel );
											$panl = $pnls;
										}

										//	Not in a panel
										else
										{
											$pnls = $('.' + _c.panel, that.$menu);
											$panl = that.$menu;
										}

										if ( opts.resultsPanel.add )
										{
											$pnls = $pnls.not( $rpnl );
										}

										var $inpt = $srch.children( 'input' ),
											$itms = that.__findAddBack( $pnls, '.' + _c.listview ).children( 'li' ),
											$dvdr = $itms.filter( '.' + _c.divider ),
											$rslt = that.__filterListItems( $itms );

										var _anchor = 'a',
											_both = _anchor + ', span';


										var query = '';
										var search = function()
										{

											var q = $inpt.val().toLowerCase();
											if ( q == query )
											{
												return;
											}
											query = q;


											if ( opts.resultsPanel.add )
											{
												$rpnl
													.children( '.' + _c.listview )
													.empty();
											}

											//	Scroll to top
											$pnls.scrollTop( 0 );

											//	Search through items
											$rslt
												.add( $dvdr )
												.addClass( _c.hidden )
												.find( '.' + _c.fullsubopensearch )
												.removeClass( _c.fullsubopen + ' ' +  _c.fullsubopensearch );

											$rslt
												.each(
													function()
													{
														var $item = $(this),
															_search = _anchor;

														if ( opts.showTextItems || ( opts.showSubPanels && $item.find( '.' + _c.next ) ) )
														{
															_search = _both;
														}

														var txt = $item.data( _d.searchtext ) || $item.children( _search ).text();
														if ( txt.toLowerCase().indexOf( query ) > -1 )
														{
															$item.add( $item.prevAll( '.' + _c.divider ).first() ).removeClass( _c.hidden );
														}
													}
												);

											//	Update sub items
											if ( opts.showSubPanels )
											{
												$pnls.each(
													function( i )
													{
														var $panl = $(this);
														that.__filterListItems( $panl.find( '.' + _c.listview ).children() )
															.each(
																function()
																{
																	var $li = $(this),
																		$su = $li.data( _d.child );

																	$li.removeClass( _c.nosubresults );
																	if ( $su )
																	{
																		$su.find( '.' + _c.listview ).children().removeClass( _c.hidden );
																	}
																}
															);
													}
												);
											}

											//	All results in one panel
											if ( opts.resultsPanel.add )
											{
												if ( query === '' )
												{
													this.closeAllPanels();
													this.openPanel( this.$pnls.children( '.' + _c.subopened ).last() );
												}
												else
												{
													var $itms = $();
													$pnls
														.each(
															function()
															{
																var $i = that.__filterListItems( $(this).find( '.' + _c.listview ).children() ).not( '.' + _c.hidden ).clone( true );
																if ( $i.length )
																{
																	if ( opts.resultsPanel.dividers )
																	{
																		$itms = $itms.add( '<li class="' + _c.divider + '">' + $(this).children( '.' + _c.navbar ).text() + '</li>' );
																	}
																	$itms = $itms.add( $i );
																}
															}
														);

													$itms
														.find( '.' + _c.next )
														.remove();

													$rpnl
														.children( '.' + _c.listview )
														.append( $itms );

													this.openPanel( $rpnl );
												}
											}

											//	Update parent for submenus
											else
											{

												$( $pnls.get().reverse() )
													.each(
														function( i )
														{
															var $panl = $(this),
																$prnt = $panl.data( _d.parent );

															if ( $prnt )
															{
																if ( that.__filterListItems( $panl.find( '.' + _c.listview ).children() ).length )
																{
																	if ( $prnt.hasClass( _c.hidden ) )
																	{
																		$prnt.children( '.' + _c.next )
																			.not( '.' + _c.fullsubopen )
																			.addClass( _c.fullsubopen )
																			.addClass( _c.fullsubopensearch );
																	}
																	$prnt
																		.removeClass( _c.hidden )
																		.removeClass( _c.nosubresults )
																		.prevAll( '.' + _c.divider )
																		.first()
																		.removeClass( _c.hidden );
																}
																else if ( !inPanel )
																{
																	if ( $panl.hasClass( _c.opened ) )
																	{
																		//	Compensate the timeout for the opening animation
																		setTimeout(
																			function()
																			{
																				that.openPanel( $prnt.closest( '.' + _c.panel ) );
																			}, ( i + 1 ) * ( that.conf.openingInterval * 1.5 )
																		);
																	}
																	$prnt.addClass( _c.nosubresults );
																}
															}
														}
													);
											}

											//	Show/hide no results message
											$panl.find( '.' + _c.noresultsmsg )[ $rslt.not( '.' + _c.hidden ).length ? 'addClass' : 'removeClass' ]( _c.hidden );

											//	Update for other addons
											this.update();
										};

										$inpt
											.off( _e.keyup + '-' + _ADDON_ + ' ' + _e.change + '-' + _ADDON_ )
											.on(  _e.keyup + '-' + _ADDON_,
												function( e )
												{
													if ( !preventKeypressSearch( e.keyCode ) )
													{
														search.call( that );
													}
												}
											)
											.on( _e.change + '-' + _ADDON_,
												function( e )
												{
													search.call( that );
												}
											);

										var $btn = $srch.children( '.' + _c.btn );
										if ( $btn.length )
										{
											$inpt
												.on( _e.keyup + '-' + _ADDON_,
													function( e )
													{
														$btn[ $inpt.val().length ? 'removeClass' : 'addClass' ]( _c.hidden );
													}
												);
										}
										$inpt.trigger( _e.keyup + '-' + _ADDON_ );
									}
								);
						}
					}
				}
		 	);
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

			_c.add( 'clear search hassearch resultspanel noresultsmsg noresults nosubresults fullsubopensearch' );
			_d.add( 'searchtext' );
			_e.add( 'change keyup' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		add 			: false,
		addTo			: 'panels',
		placeholder		: 'Search',
		noResults		: 'No results found.',
		resultsPanel 	: {
			add 			: false,
			dividers		: true,
			title			: 'Search results'
		},
		search			: true,
		showTextItems	: false,
		showSubPanels	: true
	};
	$[ _PLUGIN_ ].configuration[ _ADDON_ ] = {
		clear			: false,
		form			: false,
		input			: false,
		submit			: false
	};
	

	var _c, _d, _e, glbl;


	function preventKeypressSearch( c )
	{
		switch( c )
		{
			case 9:		//	tab
			case 16:	//	shift
			case 17:	//	control
			case 18:	//	alt
			case 37:	//	left
			case 38:	//	top
			case 39:	//	right
			case 40:	//	bottom
				return true;
		}
		return false;
	}

})( jQuery );
/*	
 * jQuery mmenu sectionIndexer add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'sectionIndexer';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					add: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			this.bind( 'initPanels',
				function( $panels )
				{
					//	Set the panel(s)
					if ( opts.add )
					{
						var $wrapper;
						switch( opts.addTo )
						{
							case 'panels':
								 $wrapper = $panels;
								break;
			
							default:
								$wrapper = $(opts.addTo, this.$menu).filter( '.' + _c.panel );
								break;
						}

						$wrapper
							.find( '.' + _c.divider )
							.closest( '.' + _c.panel )
							.addClass( _c.hasindexer );
					}


					//	Add the indexer, only if it does not allready excists
					if ( !this.$indexer && 
						this.$pnls.children( '.' + _c.hasindexer ).length
					) {
						this.$indexer = $( '<div class="' + _c.indexer + '" />' )
							.prependTo( this.$pnls )
							.append( 
								'<a href="#a">a</a>' +
								'<a href="#b">b</a>' +
								'<a href="#c">c</a>' +
								'<a href="#d">d</a>' +
								'<a href="#e">e</a>' +
								'<a href="#f">f</a>' +
								'<a href="#g">g</a>' +
								'<a href="#h">h</a>' +
								'<a href="#i">i</a>' +
								'<a href="#j">j</a>' +
								'<a href="#k">k</a>' +
								'<a href="#l">l</a>' +
								'<a href="#m">m</a>' +
								'<a href="#n">n</a>' +
								'<a href="#o">o</a>' +
								'<a href="#p">p</a>' +
								'<a href="#q">q</a>' +
								'<a href="#r">r</a>' +
								'<a href="#s">s</a>' +
								'<a href="#t">t</a>' +
								'<a href="#u">u</a>' +
								'<a href="#v">v</a>' +
								'<a href="#w">w</a>' +
								'<a href="#x">x</a>' +
								'<a href="#y">y</a>' +
								'<a href="#z">z</a>' );

						//	Scroll onMouseOver
						this.$indexer
							.children()
							.on( _e.mouseover + '-sectionindexer ' + _c.touchstart + '-sectionindexer',
								function( e )
								{
									var lttr = $(this).attr( 'href' ).slice( 1 ),
										$panl = that.$pnls.children( '.' + _c.current ),
										$list = $panl.find( '.' + _c.listview );

									var newTop = false,
										oldTop = $panl.scrollTop();

									$panl.scrollTop( 0 );
									$list
										.children( '.' + _c.divider )
										.not( '.' + _c.hidden )
										.each(
											function()
											{
												if ( newTop === false &&
													lttr == $(this).text().slice( 0, 1 ).toLowerCase()
												) {
													newTop = $(this).position().top;
												}
											}
										);
									$panl.scrollTop( newTop !== false ? newTop : oldTop );
								}
							);


						//	Show or hide the indexer
						var update = function( $panl )
						{
							that.$menu[ ( $panl.hasClass( _c.hasindexer ) ? 'add' : 'remove' ) + 'Class' ]( _c.hasindexer );
						};

						this.bind( 'openPanel', update );
						update.call( this, this.$pnls.children( '.' + _c.current ) );
					}
				}
			);
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

			_c.add( 'indexer hasindexer' );
			_e.add( 'mouseover touchstart' );
		},
		
		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu )
		{
			if ( $a.parent().is( '.' + _c.indexer ) )
			{
				return true;
			}
		}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		add		: false,
		addTo	: 'panels'
	};


	var _c, _d, _e, glbl;

})( jQuery );
/*	
 * jQuery mmenu setSelected add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'setSelected';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			//	Extend shorthand options
			if ( typeof opts == 'boolean' )
			{
				opts = {
					hover	: opts,
					parent	: opts
				};
			}
			if ( typeof opts != 'object' )
			{
				opts = {};
			}
			opts = this.opts[ _ADDON_ ] = $.extend( true, {}, $[ _PLUGIN_ ].defaults[ _ADDON_ ], opts );


			//	Find current by URL
			if ( opts.current == 'detect' )
			{
				var findCurrent = function( url )
				{
					url = url.split( "?" )[ 0 ].split( "#" )[ 0 ];

					var $a = that.$menu.find( 'a[href="'+ url +'"], a[href="'+ url +'/"]' );
					if ( $a.length )
					{
						that.setSelected( $a.parent(), true );
					}
					else
					{
						url = url.split( '/' ).slice( 0, -1 );
						if ( url.length )
						{
							findCurrent( url.join( '/' ) );
						}
					}
				};

				findCurrent( window.location.href );
			}

			//	Remove current selected item
			else if ( !opts.current )
			{
				this.bind( 'initPanels',
					function( $panels )
					{
						$panels
							.find( '.' + _c.listview )
							.children( '.' + _c.selected )
							.removeClass( _c.selected );
					}
				);
			}


			//	Add :hover effect on items
			if ( opts.hover )
			{
				this.$menu.addClass( _c.hoverselected );
			}


			//	Set parent item selected for submenus
			if ( opts.parent )
			{
				this.$menu.addClass( _c.parentselected );

				var update = function( $panel )
				{
					//	Remove all
					this.$pnls
						.find( '.' + _c.listview )
						.find( '.' + _c.next )
						.removeClass( _c.selected );

					//	Move up the DOM tree
					var $li = $panel.data( _d.parent );
					while ( $li && $li.length )
					{
						$li = $li
							.not( '.' + _c.vertical )
							.children( '.' + _c.next )
							.addClass( _c.selected )
							.end()
							.closest( '.' + _c.panel )
							.data( _d.parent );
					}
				};

				this.bind( 'openedPanel', update );
				this.bind( 'initPanels',
					function( $panls )
					{
						update.call( this, this.$pnls.children( '.' + _c.current ) );
					}
				);
			}
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;

			_c.add( 'hoverselected parentselected' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options
	$[ _PLUGIN_ ].defaults[ _ADDON_ ] = {
		current : true,
		hover	: false,
		parent	: false
	};


	var _c, _d, _e, glbl;


})( jQuery );
/*	
 * jQuery mmenu toggles add-on
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 */

(function( $ ) {

	var _PLUGIN_ = 'mmenu',
		_ADDON_  = 'toggles';


	$[ _PLUGIN_ ].addons[ _ADDON_ ] = {

		//	setup: fired once per menu
		setup: function()
		{
			var that = this,
				opts = this.opts[ _ADDON_ ],
				conf = this.conf[ _ADDON_ ];

			glbl = $[ _PLUGIN_ ].glbl;


			this.bind( 'initPanels',
				function( $panels )
				{

					//	Refactor toggle classes
					this.__refactorClass( $('input', $panels), this.conf.classNames[ _ADDON_ ].toggle, 'toggle' );
					this.__refactorClass( $('input', $panels), this.conf.classNames[ _ADDON_ ].check, 'check' );
			

					//	Add markup
					$('input.' + _c.toggle + ', input.' + _c.check, $panels)
						.each(
							function()
							{
								var $inpt = $(this),
									$prnt = $inpt.closest( 'li' ),
									cl = $inpt.hasClass( _c.toggle ) ? 'toggle' : 'check',
									id = $inpt.attr( 'id' ) || that.__getUniqueId();

								if ( !$prnt.children( 'label[for="' + id + '"]' ).length )
								{
									$inpt.attr( 'id', id );
									$prnt.prepend( $inpt );
			
									$('<label for="' + id + '" class="' + _c[ cl ] + '"></label>')
										.insertBefore( $prnt.children( 'a, span' ).last() );
								}
							}
						);
				}
			);
		},

		//	add: fired once per page load
		add: function()
		{
			_c = $[ _PLUGIN_ ]._c;
			_d = $[ _PLUGIN_ ]._d;
			_e = $[ _PLUGIN_ ]._e;
	
			_c.add( 'toggle check' );
		},

		//	clickAnchor: prevents default behavior when clicking an anchor
		clickAnchor: function( $a, inMenu ) {}
	};


	//	Default options and configuration
	$[ _PLUGIN_ ].configuration.classNames[ _ADDON_ ] = {
		toggle	: 'Toggle',
		check	: 'Check'
	};


	var _c, _d, _e, glbl;

})( jQuery );